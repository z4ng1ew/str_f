#include <stdio.h>
#include <string.h>
#include "Some_string.h"



/*

Тип данных:

1) strncmp работает со строками, учитывая символы и их значения в таблице ASCII.strncmp сравнивает строки, состоящие из символов, и учитывает специальный символ окончания строки \0.

2) memcmp работает с произвольными блоками памяти, сравнивая данные побайтно.memcmp сравнивает произвольные блоки памяти, не обращая внимания на символ окончания строки.



    Возвращаемое значение:

    1) Возвращает отрицательное значение, если первая строка меньше второй.
    2) Возвращает ноль, если строки равны.
    3) Возвращает положительное значение, если первая строка больше второй.

    Особенности:

    1) Сравнивает символы как символы, учитывая их значение в таблице ASCII.
    2) Останавливает сравнение, если достигает символа конца строки (\0) в одной из строк до сравнения всех n символов.



    Применение:

    1) strncmp подходит для сравнения строк или массивов символов.

    2) memcmp подходит для сравнения произвольных блоков памяти, включая данные, не являющиеся строками.
 */





int s21_strncmp(const char *str1, const char *str2, s21_size_t n) {

    /*
     * Параметры функции:

    1) const char *str1: указатель на первую строку для сравнения.
    2) const char *str2: указатель на вторую строку для сравнения.
    3) s21_size_t n: количество символов, которые нужно сравнить (определено как unsigned long long).
    */

    int comparisonResult = 0;  // Переменная для хранения разницы между символами строк.
    s21_size_t index = 0; // Счетчик для отслеживания текущей позиции в строках.

    while (index != n)  { // Цикл продолжается, пока не будут проверены все n символов.
        if (*(str1 + index) != *(str2 + index)) { // Выражение if (*(str1 + index) != *(str2 + index)) сравнивает символы из двух строк str1 и str2 на позиции index. Указатели используются для смещения и доступа к элементам строк, а оператор != проверяет, равны ли эти символы. Если символы не равны, условие становится истинным, и выполняется тело условия if.

        /*
         Адресная арифметика (pointer arithmetic):

        str1 + index и str2 + index используют адресную арифметику для вычисления адреса элемента в массиве.

        str1 и str2 — указатели на строки (или массивы символов). index — целочисленная переменная, представляющая количество байтов (или символов), которые нужно сместить от начального адреса str1 или str2.


         Дереференция (dereferencing)  указателя — это операция, которая позволяет получить значение, на которое указывает указатель. В языке C для этого используется оператор *.:

            В этом примере str — это указатель на строку. Оператор * перед str позволяет получить значение первого символа строки, на которую указывает str, то есть 'h'.


        *(str1 + index) и *(str2 + index) выполняют дереференцию указателя, т.е. извлекают значение по вычисленному адресу.

        Например, если str1 указывает на строку "hello", *(str1 + 1) будет символом 'e', так как str1 + 1 указывает на второй символ строки.

        // Это эквивалентно доступу к элементам массива по индексу, но через указатели.

        Арифметика указателей в выражении str1 + index используется для доступа к элементам строки по индексу. Давайте подробнее разберем, почему это необходимо и как это работает.



        Зачем нужна арифметика указателей?

        Доступ к элементам массива (строки):

        Строки в C представлены как массивы символов. Например, строка "hello" представлена в памяти как массив ['h', 'e', 'l', 'l', 'o', '\0'].

        Указатель на строку (const char *str1) указывает на первый элемент этого массива (символ 'h').



        Смещение указателя:

        Арифметика указателей позволяет смещать указатель на определенное количество байт, чтобы получить доступ к другим элементам массива.

        Например, str1 + 1 указывает на второй элемент строки (символ 'e').

        Как работает арифметика указателей?



        Смещение указателя:

        В выражении str1 + index, если str1 указывает на начало строки, то str1 + index указывает на элемент, который находится на расстоянии index от начала строки.

        Если index = 0, str1 + index указывает на первый элемент.

        Если index = 1, str1 + index указывает на второй элемент.

        Дереференция указателя:

        Оператор * используется для получения значения элемента, на который указывает указатель.

        В выражении *(str1 + index), str1 + index указывает на нужный элемент строки, а * позволяет получить этот элемент.

        Пример:

        Рассмотрим строку и указатель:

        const char *str1 = "hello";
        str1 указывает на первый символ строки 'h'.
        Теперь рассмотрим арифметику указателей:

        str1 + 0 указывает на 'h' (первый символ).
        str1 + 1 указывает на 'e' (второй символ).
        str1 + 2 указывает на 'l' (третий символ).
        str1 + 3 указывает на 'l' (четвертый символ).
        str1 + 4 указывает на 'o' (пятый символ).


        str1 + index будет указывать на второй символ строки str1, т.е. 'e'.
        str2 + index будет указывать на второй символ строки str2, т.е. 'o'.
        *(str1 + index) извлечет значение 'e'.
        *(str2 + index) извлечет значение 'o'.
        if (*(str1 + index) != *(str2 + index)) проверит, равны ли 'e' и 'o'. Поскольку они не равны, условие будет истинным








            Сравнение символов:

            if ('e' != 'o') проверяет, равны ли эти два символа.

            Поскольку 'e' и 'o' не равны, условие будет истинным.


            Конкретное сравнение:

            *(str1 + index) и *(str2 + index) сравнивают символы на позиции index в строках str1 и str2.

            Эти символы сравниваются по их значению в таблице ASCII.

            Например, 'e' имеет значение ASCII 101, а 'o' имеет значение ASCII 111.

            Сравнение 101 != 111 будет истинным.

        */

            comparisonResult = *(str1 + index) - *(str2 + index); // Если символы не равны, вычисляется разница и цикл завершает работу.

            index = n;

            // Например, если *(str1 + index) вернуло 'e' (ASCII 101), а *(str2 + index) вернуло 'o' (ASCII 111), то разница будет 101 - 111 = -10.

            // В строке comparisonResult = *(str1 + index) - *(str2 + index); переменная comparisonResult хранит разницу между значениями символов (типа char), на которые указывают смещенные указатели, а не разницу между самими указателями. Это позволяет функции s21_strncmp сравнивать символы строк и определять, какая строка "меньше" или "больше" в лексикографическом порядке.




        } else {
            index++; // Если символы равны, index увеличивается, чтобы перейти к следующему символу.
        }
    }

    return comparisonResult; // Функция возвращает comparisonResult, который будет 0, если все n символов равны, или разницу первого найденного неравенства.
}




int main(){
    char str1[] = "Buy!";
    char str2[] = "Buy!";

    s21_size_t n = 4;

    int res = s21_strncmp(str1, str2, n);

    if(res == 0){
        printf("Первые %llu символы строки равны. \n", n);
    } else if (res < 0) {
        printf("Первые %llu символы  string_One меньше чем string_Two.\n", n);
    } else {
        printf("Первые %llu символы  string_One больше чем string_Two\n", n);
    }

    return 0;
}

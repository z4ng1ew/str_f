#include <stdio.h>
#include <string.h>
#include "Some_string.h"



char *s21_strpbrk(const char *str1, const char *str2) {

    //str1 — строка, в которой функция будет искать.
    //str2 — строка, содержащая символы, которые мы ищем в str1.



    char *found_char_ptr = s21_NULL;
    int str1_length = strlen(str1);
    int str2_length = strlen(str2);
    int found = 0;

    // Внешний цикл проходит по строке str1
    for (int i = 0; i < str1_length && !found; i++) {
        // Внутренний цикл проходит по строке str2
        for (int j = 0; j < str2_length && !found; j++) {
            if (str1[i] == str2[j]) {
                found_char_ptr = (char *)(str1 + i); //как только находится совпавший символ i смещает указатель str1 на i позиций вперед, в соответствии с количеством итераций

                /* Почему происходит привдение типов ?

                Типы данных:

                str1 имеет тип const char *, что означает, что указатель str1 указывает на неизменяемые данные.

                found_char_ptr объявлена как char *, что означает, что указатель может указывать на изменяемые данные.
                
                Проблема без приведения типов:

                Когда вы пытаетесь присвоить указатель типа const char * (то есть результат str1 + i) переменной типа char *, компилятор выдает предупреждение, потому что это действие может привести к изменению данных, которые изначально должны быть неизменяемыми. Это называется потерей квалификатора const.
                
                Решение с приведением типов:

                Приведение типа (char *)(str1 + i) явно указывает компилятору, что вы сознательно хотите игнорировать квалификатор const и работать с указателем как с char *. Это устраняет предупреждение компилятора, так как компилятор теперь понимает, что вы берете на себя ответственность за возможные последствия изменения данных.
                
                Сохраняется ли константность данных?
                
                Нет, приведение типов не сохраняет константность данных. Приведение типа const char * к char * снимает квалификатор const, позволяя изменять данные, на которые указывает указатель. Поэтому нужно использовать это с осторожностью и понимать возможные риски.
                
                */


                found = 1; // Устанавливаем флаг найденного совпадения и остпнпвливает цикл
            }
        }
    }
    return found_char_ptr; 
}


int main(){
    char string[] = "Hello, World!";
    char ac[] = "ssl";

    //Первое вхождение гласного символа: e
    //Остаток строки начиная с первого вхождения: ello, World!

    char *res = s21_strpbrk(string, ac);



    if (res) {
        printf("Первое вхождение гласного символа: %c\n", *res);
        printf("Остаток строки начиная с первого вхождения: %s\n", res);
    } else {
        printf("Гласные символы не найдены.\n");
    }

    return 0;
}
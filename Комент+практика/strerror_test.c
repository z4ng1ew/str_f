#include <stdio.h>
#include <errno.h> //Расшифровывается это название как "error nomber", что в переводе на русский означает "номер ошибки".
#include <string.h>  // Добавлено для доступа к strerror


int main(){

    FILE *file_pointer = fopen("nonexistentfile.txt", "r");
    if (file_pointer == NULL){ //в языке программирования C обозначает указатель на структуру типа FILE, которая используется для управления потоками данных в файловой системе. Структура FILE является стандартным способом представления файлов и потоков ввода/вывода в стандартной библиотеке C и предоставляется через заголовочный файл <stdio.h>

    //FILE: Это определенный в библиотеке C тип данных, который представляет информацию о файле и его состоянии (например, позиция в файле, статус ошибок и т. д.). Структура FILE скрыта от пользователя, и взаимодействие с ней происходит через функции стандартной библиотеки.

    // *file_pointer: Здесь file_pointer является указателем на структуру типа FILE. Использование указателя позволяет функциям, работающим с файлами, изменять свои свойства и состояние напрямую, что обеспечивает удобное управление файлами в программе.

    //Здесь fopen используется для открытия файла "example.txt" для чтения ("r"). Функция возвращает указатель на FILE, который сохраняется в переменной file_pointer. Если файл не удаётся открыть, fopen вернёт NULL.

    /*
    В контексте C, fp часто используется как сокращение для "file pointer", что переводится на русский язык как "указатель на файл". В строке кода:


    FILE *fp = fopen("example.txt", "r");
    fp является переменной, содержащей указатель на объект типа FILE, который возвращается функцией fopen. Этот указатель используется для управления файловым потоком в последующих операциях ввода-вывода, таких как чтение из файла, запись в файл, перемещение позиции чтения/записи в файле и закрытие файла.

    Детальное объяснение:
    FILE *: Означает, что fp является указателем на тип FILE, который представляет собой структуру, содержащую информацию о файле, включая, например, его текущее состояние, позицию данных и буферизацию.

    fopen("example.txt", "r"): Эта функция пытается открыть файл с именем "example.txt" для чтения (режим "r" означает "read"). Если файл успешно открыт, fopen возвращает указатель на структуру FILE, которая теперь ассоциирована с открытым файлом. Если файл открыть не удалось, возвращается NULL, и значение errno устанавливается для указания причины ошибки.
    */
    
        int error_number = errno; //Глобальная переменная, используемая библиотечными функциями для указания ошибок.


        /*
        Переменная `errno` в языке программирования C используется для индикации ошибок в стандартных функциях библиотеки C и в операционных системах, основанных на стандартах POSIX. `errno` является сокращением от "error number" (номер ошибки). Эта переменная является глобальной и изменяется многими функциями, когда в результате их выполнения возникает ошибка.

### Как работает `errno`:

1. **Установка значения:** Когда стандартная функция (например, `open()`, `read()`, `fopen()` и т.д.) сталкивается с ошибкой, она устанавливает `errno` в конкретный код ошибки, который помогает определить, что именно пошло не так. Каждый код ошибки имеет своё уникальное значение, которое соответствует определённому типу ошибки.

2. **Значение по умолчанию:** Перед вызовом функции `errno` обычно должно быть установлено в `0`. Это делается для того, чтобы можно было точно узнать, вызвала ли последующая функция ошибку, поскольку не все функции обнуляют `errno` в случае успеха.

3. **Чтение `errno`:** После выполнения функции, которая может установить `errno`, следует немедленно проверить значение `errno`, если функция сообщает об ошибке (обычно это значит, что функция вернула значение, указывающее на ошибку, например, `-1` для многих системных вызовов). Значение `errno` может быть преобразовано в читаемый текст с помощью функции `strerror()`, которая возвращает строку, описывающую ошибку.

### Примеры кодов ошибок:

- `ENOENT` (нет такого файла или каталога): Часто устанавливается функциями, которые пытаются доступиться к файлу или каталогу, которого не существует.
- `EACCES` (отказано в доступе): Устанавливается, когда программе не разрешено совершить операцию из-за ограничений доступа.
- `ENOMEM` (не хватает памяти): Устанавливается, когда системные вызовы не могут выделить достаточно памяти.

### Пример использования `errno`:

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

int main() {
    FILE *fp = fopen("nonexistentfile.txt", "r");
    if (fp == NULL) {
        printf("Ошибка открытия файла: %s\n", strerror(errno));
    } else {
        // Операции с файлом
        fclose(fp);
    }
    return 0;
}
```

В этом примере, если файл не удаётся открыть, `fopen()` устанавливает `errno` в соответствующий код ошибки (например, `ENOENT`), и программа использует `strerror()` для вывода описания ошибки.

`errno` является фундаментальным инструментом для диагностики и обработки ошибок в программах на C, позволяя разработчикам более точно понимать и реагировать на различные ситуации, которые могут возникнуть во время выполнения программы.
        */




        printf("Ошибка открытия файла: %s\n", strerror(error_number));
    } else {
        printf("Файл успешно открыт.\n");
        fclose(file_pointer);
    }
    return 0;
}
#include "../s21_string.h"

void *s21_memcpy(void *dest, const void *src, s21_size_t n) {

// void *dest — указатель на область памяти, куда будут копироваться данные.
// const void *src — указатель на область памяти, откуда будут копироваться данные.
// s21_size_t n — количество байт для копирования.


  for (s21_size_t byteIndex = 0; byteIndex < n; byteIndex++) { //Цикл for выполняется n раз, где n — количество байт для копирования.

    *((char *)dest + byteIndex) = *((char *)src + byteIndex); //(char *)dest + i и (char *)src + i выполняют арифметику указателей с типом char, чтобы копировать данные по одному байту за раз.

    //В C, оператор присваивания (=) работает так, что значение выражения справа от оператора присваивается левой стороне оператора.Поэтому правильный порядок должен быть таким, чтобы значение из src (источника) копировалось в dest (назначение).

    //void * является обобщенным указателем, который может указывать на данные любого типа, но не может быть напрямую использован в арифметических операциях.

    //Мы приводим указатели dest и src к типу char *, потому что тип char занимает ровно 1 байт в памяти. Это позволяет нам выполнять побайтовое копирование.

    //После приведения указателей к типу char *, мы используем byteIndex для перемещения по байтам.
    
    // byteIndex указывает на текущий байт, который мы копируем. Например, если byteIndex равно 2, то (char *)dest + byteIndex указывает на третий байт в области памяти dest.

    //Разыменование (*) позволяет получить значение, находящееся по адресу, на который указывает указатель.
    //*((char *)src + byteIndex) получает значение байта из исходной области памяти src, на которое указывает (char *)src + byteIndex.

    //*((char *)dest + byteIndex) записывает это значение в область памяти назначения dest, на адрес (char *)dest + byteIndex.
  }
  
  return dest; //функция возвращает указатель на  уже скопированный массив
}



/*
Рассмотрим ваше предложение по изменению порядка выражений и объясним, почему текущий порядок является правильным.

### Текущий порядок:

```c
*((char *)dest + byteIndex) = *((char *)src + byteIndex);
```

### Ваше предложение:

```c
*((char *)src + byteIndex) = *((char *)dest + byteIndex);
```

### Пояснение:

- В C, оператор присваивания (`=`) работает так, что значение выражения справа от оператора присваивается левой стороне оператора.
- Поэтому правильный порядок должен быть таким, чтобы значение из `src` (источника) копировалось в `dest` (назначение).

### Давайте рассмотрим оба варианта:

1. **Текущий порядок:**
   
   ```c
   *((char *)dest + byteIndex) = *((char *)src + byteIndex);
   ```

   - `*((char *)src + byteIndex)`: Получает значение байта из массива `src`.
   - `*((char *)dest + byteIndex)`: Записывает это значение в массив `dest`.

   Это соответствует логике копирования: мы берем значение из источника и записываем его в назначение.

2. **Ваше предложение:**
   
   ```c
   *((char *)src + byteIndex) = *((char *)dest + byteIndex);
   ```

   - `*((char *)dest + byteIndex)`: Получает значение байта из массива `dest`.
   - `*((char *)src + byteIndex)`: Пытается записать это значение в массив `src`.

   В этом случае происходит противоположное действие, что не соответствует цели функции `memcpy`. Цель функции `memcpy` - копировать данные из источника в назначение, а не наоборот.

### Пример:

Допустим, у нас есть массивы:

- `src`: `{10, 20, 30, 40, 50}`
- `dest`: `{0, 0, 0, 0, 0}`

#### Текущий порядок (правильный):

```c
*((char *)dest + byteIndex) = *((char *)src + byteIndex);
```

- `byteIndex = 0`: `dest[0] = src[0]` → `dest[0] = 10`
- `byteIndex = 1`: `dest[1] = src[1]` → `dest[1] = 20`
- ...

В итоге: `dest = {10, 20, 30, 40, 50}`

#### Ваше предложение (неправильный):

```c
*((char *)src + byteIndex) = *((char *)dest + byteIndex);
```

- `byteIndex = 0`: `src[0] = dest[0]` → `src[0] = 0`
- `byteIndex = 1`: `src[1] = dest[1]` → `src[1] = 0`
- ...

В итоге: `src = {0, 0, 0, 0, 0}`

Таким образом, текущий порядок выражения является правильным, поскольку он соответствует логике копирования данных из одного массива в другой. Операция копирования всегда должна идти от источника к назначению, чтобы данные корректно передавались из одного места в другое.
*/
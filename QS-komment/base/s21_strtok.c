#include "../s21_string.h"


//strtok расшифровывается как "string token" (строковый токен). Это функция из стандартной библиотеки языка программирования C, которая используется для разбиения строки на части (токены) с использованием разделителей (delimiters).

//strtok() — это функция из стандартной библиотеки языка программирования C, предназначенная для разбиения строки на последовательные части, называемые токенами, с использованием определённых символов-разделителей. Она позволяет выделять подстроки (токены) из исходной строки поочередно при каждом вызове.

//Функция strtok() используется для разбивки строки на отдельные части (токены) на основе одного или нескольких символов-разделителей. При первом вызове функции ей передается исходная строка и набор символов-разделителей. Функция находит первый токен и возвращает указатель на него, изменяя исходную строку. Для получения последующих токенов strtok() вызывается повторно, передавая в качестве аргумента NULL вместо исходной строки, и она продолжает обрабатывать ту же самую строку с места, где закончила в предыдущий раз.


//Другими словами, функция strtok() разбивает строку на слова или части (токены), используя указанные символы-разделители. В этом контексте "слова" — это последовательности символов, отделенные друг от друга одним или несколькими символами-разделителями (то есть с использованием пробелов, запятых, точек и восклицательных знаков в качестве разделителей).


char *s21_strtok(char *str, const char *delim) {

  //в функцию передаётся указатель на  строку - *str и указатель на то чем мы будем делить эту строку *delim

  static char * current_position_tokenization; //current_position_tokenization  указывает на то, что переменная хранит текущее положение в строке для токенизации // Объявляем статическую переменную для хранения указателя на строку между вызовами функции 

  //Переменная static char *current_position_tokenization хранит указатель на текущее положение в строке, которую нужно разбить на токены. Это позволяет функции s21_strtok продолжать разбиение строки при последующих вызовах.

  //Переменная объявлена как static, что означает, что её значение сохраняется между вызовами функции. Таким образом, она сохраняет текущее положение в строке между вызовами s21_strtok, что позволяет продолжать разбиение строки с того места, где оно остановилось в предыдущий раз.

  //Когда функция s21_strtok вызывается с NULL вместо строки, она использует значение, сохраненное в current_position_tokenization, чтобы продолжить разбиение строки. Это поведение аналогично стандартной функции strtok.

  //В контексте функции s21_strtok переменная current_position_tokenization необходима для хранения текущего состояния строки между вызовами функции. Это позволяет корректно разбирать строку на части (токены), используя переданные разделители.


  /*
  
  Объяснение работы переменной current_position_tokenization в примере:

  Первый вызов:

  При первом вызове s21_strtok с начальной строкой str, current_position_tokenization инициализируется указателем на начало этой строки.

  Разделители пропускаются, и current_position_tokenization указывает на начало первого токена.
  
  Найден первый токен, который заканчивается первым разделителем, заменяется нуль-терминатором, и указатель current_position_tokenization обновляется, чтобы указывать на следующий символ после разделителя.
  
  Последующие вызовы:

  
  При следующих вызовах с NULL в качестве первого параметра, функция продолжает разбиение строки, используя сохраненное значение  current_position_tokenization.

  Каждый раз пропускаются начальные разделители, если они есть, и определяется следующий токен.

  Процесс продолжается до тех пор, пока не будут обработаны все токены, или пока не будет достигнут конец строки.
  
  Заключение

  Переменная static char *current_position_tokenization играет ключевую роль в сохранении состояния между вызовами функции s21_strtok, что позволяет функции корректно обрабатывать строку, разбивая её на токены, и возвращая их последовательно при каждом вызове.


  */

  char *result_position = s21_NULL; //В переменной result_position изначально хранится значение s21_NULL, что эквивалентно NULL. Впоследствии в result_position будет храниться указатель на (результирующий) текущий токен (часть строки), найденный функцией s21_strtok.Изначально равен NULL

  //В переменной result_position изначально хранится значение s21_NULL, что эквивалентно NULL. Впоследствии в result_position будет храниться указатель на текущий токен (часть строки), найденный функцией s21_strtok.

  //Цель объявления переменной result_position — хранение указателя на текущий токен, который будет возвращен функцией s21_strtok. Эта переменная используется для того, чтобы сохранить начало текущего токена, найденного в строке, до тех пор, пока он не будет возвращен.


  //Переменная result_position служит для хранения указателя на текущий токен, найденный в процессе работы функции. Она инициализируется значением NULL, чтобы обеспечить корректное поведение функции, если токен не будет найден, и используется для возврата результата работы функции.

  /*
  Переменная result_position объявлена в начале функции и используется на протяжении всей функции для следующих целей:

  Инициализация значения:

  В начале функции result_position инициализируется значением s21_NULL, что эквивалентно NULL. Это позволяет избежать возврата неинициализированного значения в случае, если не будет найден ни один токен.
  
  Хранение указателя на текущий токен:

  В процессе работы функции, если найден токен, указатель на его начало сохраняется в переменной result_position.

  Возврат текущего токена:

  В конце функции значение переменной result_position возвращается как результат работы функции. Это позволяет функции возвращать указатель на текущий токен или NULL, если токенов больше нет.
  */

  char *delimiter_position; //В переменной delimiter_position хранится указатель на первый разделитель, найденный в текущем токене. Эта переменная используется для определения конца текущего токена и для корректного завершения токена путем замены разделителя на нуль-терминатор.

  //Она сохраняет указатель на первый разделитель, найденный в текущем токене.

  //Она используется для завершения текущего токена нуль-терминатором, чтобы сделать его отдельной строкой.

  //Сохранение оставшейся части строки: В функции s21_strtok, когда текущий токен найден и завершён, необходимо сохранить оставшуюся часть строки, чтобы при следующем вызове функции разбиение могло продолжиться с того места, где остановилось в последний раз.

  //Зачем это нужно? Функция s21_strtok работает итеративно, то есть при каждом вызове она должна продолжать разбиение строки с того места, где остановилась в предыдущий раз. Для этого необходимо сохранить текущее состояние строки, что и делается через переменную current_position_tokenization.




/*
Рассмотрим пример строки и делимитеров:

Строка: "Hello, world! Welcome to C programming."
Разделители: " ,.!?"

  Первый вызов s21_strtok(str, delim)
  
    1. Инициализация:
  str = "Hello, world! Welcome to C programming."
  delim = " ,.!?"
  current_position_tokenization указывает на "Hello, world! Welcome to C programming."

    2. Нахождение токена:
  Текущий токен: "Hello"
  token_end указывает на ","

    3. Завершение токена:
Заменяем "," на '\0', получаем строку: `"Hello\0 world!

*/


  if (str != s21_NULL) {
    current_position_tokenization = str; //Эта строка кода проверяет, была ли передана новая строка для разбиения. Если строка str не равна s21_NULL (эквивалентно NULL), то она инициализирует статическую переменную current_position_tokenization указателем на эту новую строку.
    
    //Если условие выполняется (то есть str не равен s21_NULL), статическая переменная current_position_tokenization инициализируется указателем на начало новой строки. Это означает, что разбиение строки будет начинаться с начала этой новой строки.
  }

  else if (current_position_tokenization != s21_NULL) {
    for (; *current_position_tokenization && s21_strchr(delim, *current_position_tokenization); current_position_tokenization++);
  }

  if (*current_position_tokenization != '\0') {
    result_position = current_position_tokenization;
    delimiter_position = result_position + s21_strcspn(result_position, delim);

    if (*delimiter_position) {
      *(delimiter_position++) = '\0';
    }

    current_position_tokenization = delimiter_position;
  }
  return result_position;
}

#include "../s21_string.h"


//strtok расшифровывается как "string token" (строковый токен). Это функция из стандартной библиотеки языка программирования C, которая используется для разбиения строки на части (токены) с использованием разделителей (delimiters).

//strtok() — это функция из стандартной библиотеки языка программирования C, предназначенная для разбиения строки на последовательные части, называемые токенами, с использованием определённых символов-разделителей. Она позволяет выделять подстроки (токены) из исходной строки поочередно при каждом вызове.

//Функция strtok() используется для разбивки строки на отдельные части (токены) на основе одного или нескольких символов-разделителей. При первом вызове функции ей передается исходная строка и набор символов-разделителей. Функция находит первый токен и возвращает указатель на него, изменяя исходную строку. Для получения последующих токенов strtok() вызывается повторно, передавая в качестве аргумента NULL вместо исходной строки, и она продолжает обрабатывать ту же самую строку с места, где закончила в предыдущий раз.


//Другими словами, функция strtok() разбивает строку на слова или части (токены), используя указанные символы-разделители. В этом контексте "слова" — это последовательности символов, отделенные друг от друга одним или несколькими символами-разделителями (то есть с использованием пробелов, запятых, точек и восклицательных знаков в качестве разделителей).


char *s21_strtok(char *str, const char *delim) {

  //в функцию передаётся указатель на  строку - *str и указатель на то чем мы будем делить эту строку *delim

  static char * cur_position_tokenization; //cur_position_tokenization  указывает на то, что переменная хранит текущее положение в строке для токенизации // Объявляем статическую переменную для хранения указателя на строку между вызовами функции 

  //Переменная static char *cur_position_tokenization хранит указатель на текущее положение в строке, которую нужно разбить на токены. Это позволяет функции s21_strtok продолжать разбиение строки при последующих вызовах.

  //Переменная объявлена как static, что означает, что её значение сохраняется между вызовами функции. Таким образом, она сохраняет текущее положение в строке между вызовами s21_strtok, что позволяет продолжать разбиение строки с того места, где оно остановилось в предыдущий раз.

  //Когда функция s21_strtok вызывается с NULL вместо строки, она использует значение, сохраненное в cur_position_tokenization, чтобы продолжить разбиение строки. Это поведение аналогично стандартной функции strtok.

  //В контексте функции s21_strtok переменная cur_position_tokenization необходима для хранения текущего состояния строки между вызовами функции. Это позволяет корректно разбирать строку на части (токены), используя переданные разделители.


  /*
  
  Объяснение работы переменной cur_position_tokenization в примере:

  Первый вызов:

  При первом вызове s21_strtok с начальной строкой str, cur_position_tokenization инициализируется указателем на начало этой строки.

  Разделители пропускаются, и cur_position_tokenization указывает на начало первого токена.
  
  Найден первый токен, который заканчивается первым разделителем, заменяется нуль-терминатором, и указатель cur_position_tokenization обновляется, чтобы указывать на следующий символ после разделителя.
  
  Последующие вызовы:

  
  При следующих вызовах с NULL в качестве первого параметра, функция продолжает разбиение строки, используя сохраненное значение  cur_position_tokenization.

  Каждый раз пропускаются начальные разделители, если они есть, и определяется следующий токен.

  Процесс продолжается до тех пор, пока не будут обработаны все токены, или пока не будет достигнут конец строки.
  
  Заключение

  Переменная static char *cur_position_tokenization играет ключевую роль в сохранении состояния между вызовами функции s21_strtok, что позволяет функции корректно обрабатывать строку, разбивая её на токены, и возвращая их последовательно при каждом вызове.


  */

  char *res_position = s21_NULL; //В переменной res_position изначально хранится значение s21_NULL, что эквивалентно NULL. Впоследствии в res_position будет храниться указатель на (результирующий) текущий токен (часть строки), найденный функцией s21_strtok.Изначально равен NULL

  //В переменной res_position изначально хранится значение s21_NULL, что эквивалентно NULL. Впоследствии в res_position будет храниться указатель на текущий токен (часть строки), найденный функцией s21_strtok.

  //Цель объявления переменной res_position — хранение указателя на текущий токен, который будет возвращен функцией s21_strtok. Эта переменная используется для того, чтобы сохранить начало текущего токена, найденного в строке, до тех пор, пока он не будет возвращен.


  //Переменная res_position служит для хранения указателя на текущий токен, найденный в процессе работы функции. Она инициализируется значением NULL, чтобы обеспечить корректное поведение функции, если токен не будет найден, и используется для возврата результата работы функции.

  /*
  Переменная res_position объявлена в начале функции и используется на протяжении всей функции для следующих целей:

  Инициализация значения:

  В начале функции res_position инициализируется значением s21_NULL, что эквивалентно NULL. Это позволяет избежать возврата неинициализированного значения в случае, если не будет найден ни один токен.
  
  Хранение указателя на текущий токен:

  В процессе работы функции, если найден токен, указатель на его начало сохраняется в переменной res_position.

  Возврат текущего токена:

  В конце функции значение переменной res_position возвращается как результат работы функции. Это позволяет функции возвращать указатель на текущий токен или NULL, если токенов больше нет.
  */

  char *delimiter_position; //В переменной delimiter_position хранится указатель на первый разделитель, найденный в текущем токене. Эта переменная используется для определения конца текущего токена и для корректного завершения токена путем замены разделителя на нуль-терминатор.

  //Она сохраняет указатель на первый разделитель, найденный в текущем токене.

  //Она используется для завершения текущего токена нуль-терминатором, чтобы сделать его отдельной строкой.

  //Сохранение оставшейся части строки: В функции s21_strtok, когда текущий токен найден и завершён, необходимо сохранить оставшуюся часть строки, чтобы при следующем вызове функции разбиение могло продолжиться с того места, где остановилось в последний раз.

  //Зачем это нужно? Функция s21_strtok работает итеративно, то есть при каждом вызове она должна продолжать разбиение строки с того места, где остановилась в предыдущий раз. Для этого необходимо сохранить текущее состояние строки, что и делается через переменную cur_position_tokenization.




/*
Рассмотрим пример строки и делимитеров:

Строка: "Hello, world! Welcome to C programming."
Разделители: " ,.!?"

  Первый вызов s21_strtok(str, delim)
  
    1. Инициализация:
  str = "Hello, world! Welcome to C programming."
  delim = " ,.!?"
  cur_position_tokenization указывает на "Hello, world! Welcome to C programming."

    2. Нахождение токена:
  Текущий токен: "Hello"
  token_end указывает на ","

    3. Завершение токена:
Заменяем "," на '\0', получаем строку: `"Hello\0 world!

*/


  if (str != s21_NULL) {
    cur_position_tokenization = str; //Эта строка обеспечивает, что при первом вызове функция начинает токенизацию с начала новой строки, а при последующих вызовах продолжает с того места, где остановилась в предыдущий раз.
  
  } // Если функция вызвана с непустым указателем на строку (str не равен NULL), это означает, что нужно начать токенизацию новой строки.  В таком случае, инициализируем статическую переменную cur_position_tokenization  указателем на начало этой новой строки (str).



// Проверяем, инициализирована ли переменная cur_position_tokenization.
// Если она не равна NULL, это означает, что:
// 1. Либо функция была вызвана с новой строкой и переменная была инициализирована в этом вызове.
// 2. Либо функция была вызвана ранее, и мы продолжаем токенизацию текущей строки с того места, где остановились.

  if (cur_position_tokenization != s21_NULL) {
    
    
    // Пропускаем начальные разделители
    while (*cur_position_tokenization != '\0' && s21_strchr(delim, *cur_position_tokenization)) { //*cur_position_tokenization != '\0'Проверяет, достигли ли мы конца строки.Если текущий символ строки (*cur_position_tokenization) не является нуль-терминатором ('\0'), условие истинно, и мы продолжаем выполнение цикла.

    // s21_strchr(delim, *cur_position_tokenization) - Проверяет, является ли текущий символ строки одним из разделителей.Функция s21_strchr ищет первый символ в строке delim, который совпадает с текущим символом строки (*cur_position_tokenization). Если такой символ найден, возвращается указатель на него, иначе возвращается NULL. Если текущий символ строки найден среди разделителей, условие истинно, и мы продолжаем выполнение цикла.

      cur_position_tokenization++; //Увеличивает указатель cur_position_tokenization, чтобы перейти к следующему символу строки.Это позволяет пропустить текущий разделитель и проверить следующий символ.

    } //Этот цикл пропускает все начальные символы-разделители и устанавливает cur_position_tokenization на первый символ, который не является разделителем.








/*   !!!!!!!!!!!!!   Давайте рассмотрим принцип работы данного цикла на конкретном примере.     !!!!!!!!!!!!!!

### Код

```c
while (*cur_position_tokenization != '\0' && s21_strchr(delim, *cur_position_tokenization)) {
  cur_position_tokenization++;
}
```

### Принцип работы

Этот цикл используется для пропуска начальных символов-разделителей в строке. Цикл продолжает перемещать указатель `cur_position_tokenization` вперед, пока текущий символ является разделителем и не достигнут конец строки.

### Пример

Допустим, у нас есть следующая строка и разделители:

- Строка: `" ,.!Hello, world!"`
- Разделители: `" ,.!?"`

### Шаги выполнения цикла

1. **Начальное состояние**:
   - `cur_position_tokenization` указывает на первый символ строки, который является пробелом (`' '`).
   - Строка выглядит так: `" ,.!Hello, world!"`
   - Разделители: `" ,.!?"`

2. **Первый шаг цикла**:
   - Текущий символ: `' '`
   - Условие: `*cur_position_tokenization != '\0'` истинно (текущий символ не является нуль-терминатором).
   - Условие: `s21_strchr(delim, ' ')` истинно (пробел найден в строке разделителей).
   - Действие: `cur_position_tokenization++`
   - `cur_position_tokenization` теперь указывает на следующий символ.

3. **Второй шаг цикла**:
   - Текущий символ: `','`
   - Условие: `*cur_position_tokenization != '\0'` истинно (текущий символ не является нуль-терминатором).
   - Условие: `s21_strchr(delim, ',')` истинно (запятая найдена в строке разделителей).
   - Действие: `cur_position_tokenization++`
   - `cur_position_tokenization` теперь указывает на следующий символ.

4. **Третий шаг цикла**:
   - Текущий символ: `'.'`
   - Условие: `*cur_position_tokenization != '\0'` истинно (текущий символ не является нуль-терминатором).
   - Условие: `s21_strchr(delim, '.')` истинно (точка найдена в строке разделителей).
   - Действие: `cur_position_tokenization++`
   - `cur_position_tokenization` теперь указывает на следующий символ.

5. **Четвертый шаг цикла**:
   - Текущий символ: `'!'`
   - Условие: `*cur_position_tokenization != '\0'` истинно (текущий символ не является нуль-терминатором).
   - Условие: `s21_strchr(delim, '!')` истинно (восклицательный знак найден в строке разделителей).
   - Действие: `cur_position_tokenization++`
   - `cur_position_tokenization` теперь указывает на следующий символ.

6. **Пятый шаг цикла**:
   - Текущий символ: `'H'`
   - Условие: `*cur_position_tokenization != '\0'` истинно (текущий символ не является нуль-терминатором).
   - Условие: `s21_strchr(delim, 'H')` ложно (буква `'H'` не найдена в строке разделителей).
   - Цикл завершает выполнение, так как одно из условий стало ложным.

### Конечное состояние

- `cur_position_tokenization` теперь указывает на первый символ токена, который не является разделителем.
- В данном примере это буква `'H'`.

### Резюме

Цикл `while` выполняет следующие задачи:
- Проверяет каждый символ строки, начиная с текущего положения, на наличие в строке разделителей.
- Перемещает указатель `cur_position_tokenization` вперед, пока не будет найден первый символ, который не является разделителем.
- Завершается, когда либо найден символ, не являющийся разделителем, либо достигнут конец строки.

Этот процесс гарантирует, что `cur_position_tokenization` будет указывать на начало следующего токена, готового для обработки в функции `s21_strtok`.
*/




    if (*cur_position_tokenization != '\0') { // Проверяем, не достигли ли мы конца строки
      
      res_position = cur_position_tokenization; // Устанавливаем res_position на текущее положение в строке, то есть на начало текущего токена    //!!! Устанавливая res_position на это значение, мы фиксируем НАЧАЛО токена. !!!! //Установка res_position на текущее положение в строке необходима для правильного определения и возврата токена. Это позволяет функции s21_strtok корректно фиксировать начало каждого токена, искать его границы и возвращать токены один за другим при последовательных вызовах функции.

      delimiter_position = res_position + s21_strcspn(res_position, delim); //Мы используем s21_strcspn, чтобы найти первый символ-разделитель после начала токена. Это определяет конец токена. // s21_strcspn(res_position, delim) возвращает количество символов до первого вхождения любого из символов-разделителей, указанных в delim, в строке, на которую указывает res_position. Добавляя это количество к res_position, получаем указатель на первый символ-разделитель  или на конец строки, если разделитель не найден.

      //s21_strcspn — это функция, которая вычисляет длину начального сегмента строки, не содержащего ни одного из символов, указанных в delim. Ее сигнатура аналогична стандартной функции strcspn, которая работает следующим образом:
      
      //Пусть у нас есть строка res_position, содержащая "Hello, world!", и delim, содержащий ", !". s21_strcspn(res_position, delim) вернет 5, потому что первый символ-разделитель (запятая) находится на шестой позиции (индекс 5) в строке "Hello, world!"

      //Если ни один из символов delim не найден в строке res_position, функция s21_strcspn вернет длину всей строки res_position.В этом случае delimiter_position будет указывать на нуль-терминатор ('\0'), который завершает строку.

      //Эта строка кода использует s21_strcspn для поиска первого символа-разделителя в текущем токене, на который указывает res_position. Возвращенное значение добавляется к res_position, чтобы получить указатель на первый символ-разделитель или на конец строки, если разделитель не найден. Это позволяет определить границу текущего токена для дальнейшей обработки в функции s21_strtok

      if (*delimiter_position != '\0') { // Проверяем, не является ли текущий символ, на который указывает delimiter_position, нуль-терминатором ('\0').// Если текущий символ не равен '\0', выполняем следующее:

    
        *delimiter_position = '\0';//Заменяем символ-разделитель на нуль-терминатор ('\0'), чтобы завершить текущий токен. Это превращает токен в отдельную строку.

        
        delimiter_position++; // Инкрементируем указатель delimiter_position, чтобы он указывал на следующий символ после нуль-терминатора. Это необходимо для корректного продолжения работы функции.

      } 
      
      

      cur_position_tokenization = delimiter_position;//Мы завершаем текущий токен нуль-терминатором и обновляем cur_position_tokenization на следующий символ после токена, чтобы функция могла продолжить токенизацию при следующем вызове. s21_strcspn(res_position, delim) возвращает количество символов в строке res_position до первого вхождения любого из символов, указанных в delim. 



    }
  }

  return res_position; //Функция s21_strtok возвращает указатель на начало текущего токена, найденного в строке. Этот токен — часть строки, разделенная указанными символами-разделителями. В каждом вызове функции s21_strtok возвращается следующий токен до тех пор, пока не будут обработаны все токены или не достигнут конец строки.
}
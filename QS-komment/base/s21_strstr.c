#include "../s21_string.h"

/*
Функция strstr расшифровывается как "string substring". Она предназначена для поиска первой позиции подстроки в строке. Функция определена в стандартной библиотеке C в заголовочном файле <string.h>.

Описание функции strstr
Функция strstr находит первое вхождение подстроки needle в строке haystack. Если подстрока найдена, функция возвращает указатель на начало первого вхождения подстроки в строке. Если подстрока не найдена, функция возвращает NULL.
*/


/* Отличия strstr от strpbrk:

strstr полезна для поиска конкретных подстрок, например, поиска слова в предложении.

strpbrk полезна для поиска первых вхождений любого символа из заданного набора, например, поиска первых гласных в строке.

*/

char *s21_strstr(const char *haystack, const char *needle) { // Функция s21_strstr ищет первое вхождение подстроки needle в строке haystack. Если подстрока найдена, она возвращает указатель на начало первого вхождения. Если подстрока не найдена, она возвращает s21_NULL.


  char *matching_word = s21_NULL;

  if (haystack != matching_word) { //Проверяется, не является ли haystack равным s21_NULL. Если haystack равен s21_NULL, функция просто возвращает s21_NULL.


    int len_needle = s21_strlen(needle);

    if (len_needle == 0) { //Если подстрока needle пустая (т.е. её длина равна 0), 
    
      matching_word = (char *)haystack; //то указатель matching_word устанавливается на начало строки haystack. (что позволяет вывести всю строку целиком)


    } else {
      while (*haystack != '\0' &&  matching_word == s21_NULL) { //*haystack - это условие проверяет, не достигнут ли конец строки haystack. 
      
      //Если текущий символ, на который указывает haystack, не равен '\0', условие *haystack истинно. 
      
      //Если текущий символ равен '\0', это означает, что мы достигли конца строки, и условие *haystack становится ложным. 
      
      //matching_word == s21_NULL - Это условие проверяет, найдено ли вхождение подстроки needle в строке haystack.

        
        if (*haystack == *needle) { //Это условие проверяет, равны ли текущие символы в строке haystack и подстроке needle. //Оператор * (разыменование) используется для получения значения, на которое указывает указатель haystack, needle. //Это условие сравнивает текущие символы в строке haystack и подстроке needle.


          const char *h = haystack;
          const char *n = needle; //Объявление временных указателей h и n, которым присваиваются значения haystack и needle, используется для временного перемещения по строкам без изменения исходных указателей haystack и needle. Это позволяет сохранить текущую позицию в исходных строках при выполнении внутреннего цикла сравнения.
          
          //Временные указатели h и n позволяют перемещаться по строкам haystack и needle без изменения самих указателей haystack и needle.
          
          //Это важно, потому что после завершения внутреннего цикла сравнения внешний цикл должен продолжить работу с исходного места в haystack.

          while (*h != '\0' && *n != '\0' && (*h == *n)) { //оператор * используется для получения значения, на которое указывает указатели - n h. (*h == *n) - это условие проверяет, равны ли текущие символы в строках haystack и needle. 
          
          //Условие *h и *n проверяют, что текущий символ строки haystack и needle не является нулевым символом ('\0'), который обозначает конец строки


            h++; 
            n++;//Итерация h++ и n++ внутри цикла while (*h && *n && (*h == *n)) необходима для последовательного сравнения каждого символа в строках haystack и needle.
          }

          if (*n  == '\0') {  //Конструкция в контексте кода выполняет проверку, достиг ли указатель n конца строки needle

          // Если это так, значит, вся подстрока needle была найдена в строке haystack, и указатель matching_word устанавливается на начало первого вхождения подстроки в строке haystack(т.е. весь needle был успешно сопоставлен с частью haystack).


            matching_word = (char *)haystack; //Если подстрока needle полностью совпала с частью строки haystack (все символы совпадают и указатель n достиг конца строки needle), устанавливаем matching_word на начало совпадения.
            
            //matching_word - это указатель, который будет указывать на начало найденного вхождения подстроки needle в строке haystack.
            
            //Приведение (char *) используется для приведения типа указателя const char * к char *, что необходимо, так как haystack объявлен как const char *, а matching_word как char *.
          }

        }
        haystack++; //Итерация haystack++ в контексте данной функции необходима для последовательного продвижения по строке haystack и проверки каждого символа на соответствие началу подстроки needle //Если убрать haystack++, указатель haystack останется на той же позиции, и сравнение будет происходить только на первой позиции строки haystack. Это приведет к бесконечному циклу, если подстрока needle не найдена в первой позиции haystack.
      }
    }
  }
  
  return matching_word; //оператор возвращает указатель на начало первого вхождения подстроки needle в строке haystack
}



/*

Пример
Допустим, у нас есть строки haystack = "Hello, world!" и needle = "world".

Указатели h и n инициализируются на текущие позиции haystack и needle.
Внутренний цикл сравнивает символы по очереди:
h = 'w', n = 'w' (совпадают, цикл продолжается).
h = 'o', n = 'o' (совпадают, цикл продолжается).
h = 'r', n = 'r' (совпадают, цикл продолжается).
h = 'l', n = 'l' (совпадают, цикл продолжается).
h = 'd', n = 'd' (совпадают, цикл продолжается).
h = '!', n = '\0' (конец needle, цикл завершается).
Если цикл завершается, это означает, что подстрока needle полностью найдена в строке haystack, начиная с текущей позиции указателя haystack.

Итог
Цикл while (*h && *n && (*h == *n)) используется для сравнения символов строк haystack и needle до тех пор, пока символы совпадают и не достигнут конец одной из строк.
*/
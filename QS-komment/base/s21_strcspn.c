#include "../s21_string.h"

//Функция strcspn в языке программирования C расшифровывается как "string complement span" - str - c - spn. Это означает "диапазон дополнения строки". В контексте этой функции "дополнение" относится к тем символам первой строки (str1), которые не содержатся во второй строке (str2). Функция измеряет длину начального сегмента строки str1, в котором нет ни одного символа, присутствующего в строке str2.



// Функция s21_strcspn измеряет длину начального сегмента строки str1, в котором не содержится ни одного символа из строки str2.

//Функция итерирует по каждому символу в строке str1 и проверяет, встречается ли этот символ в строке str2.

s21_size_t s21_strcspn(const char *str1, const char *str2) {
  s21_size_t length_before_first_match = 0; // Хранит количество символов из str1, которые были просмотрены до того, как было найдено совпадение с любым из символов в str2.
  int match_indicator = 0; //Флаг, который показывает, найдено ли совпадение среди символов str2. Если совпадение найдено, переменная устанавливается в значение 1, иначе остаётся 0.

   while (*str1) { //Перебирает каждый символ первой строки str1 до тех пор, пока не дойдет до терминирующего нулевого символа, который обозначает конец строки.

      const char *scanPtr = str2; //создание временного указателя scanPtr, который используется для итерации по символам строки str2. //Это важно, потому что вам нужно многократно проверять каждый символ строки str1 против всех символов в str2. Если бы вы использовали непосредственно str2 для итерации, исходный адрес строки терялся бы после первой полной проверки, что сделало бы невозможным повторное использование str2 для следующих символов str1. 
   
      //Путём инициализации scanPtr начальным адресом str2 перед каждым таким перебором, вы обеспечиваете независимость каждой итерации. Другими словами, для каждого символа в str1 вы начинаете проверку с первого символа str2.

      //Когда вы проверяете символ из str1 против str2, scanPtr перемещается по str2, сравнивая каждый его символ с текущим символом str1. Как только вы достигаете конца str2, если совпадение не найдено, вы увеличиваете счётчик length_before_first_match и переходите к следующему символу str1, начиная новый перебор str2 с его начала с помощью новой инициализации scanPtr.

    
      
      while (*scanPtr != '\0') { //Условие while (*scanPtr) в контексте функции strcspn или аналогичных функций проверки строк используется для итерации по символам строки, на которую указывает scanPtr
      
      //В C, *scanPtr обозначает разыменование указателя scanPtr, то есть доступ к значению, на которое указывает этот указатель. В данном случае, scanPtr — это указатель на символы в строке str2.

      //Когда вы пишете while (*scanPtr), это условие проверяет значение символа, на который указывает scanPtr.

      //В строках C, конец строки обозначается нулевым символом \0. Этот символ имеет числовое значение 0, что в логическом контексте означает false.

      //Смысл условия while (*scanPtr):
      // Перебор символов: Цикл продолжается до тех пор, пока *scanPtr не станет равен 0, то есть пока не будет достигнут конец строки. Это позволяет итерировать по всей строке str2 для проверки каждого символа.

      // Прекращение на конце строки: Как только встречается символ \0, который является признаком окончания строки, условие while (*scanPtr) становится ложным (false), и цикл прекращается.


         if (*str1 == *scanPtr) { //разыменование указателя,то есть доступ к значению, на которое указывает этот указатель
         
         //*str1 и *scanPtr являются разыменованными значениями указателей. Это значит, что в данной операции сравниваются текущие символы, на которые указывают str1 и scanPtr.

            match_indicator = 1; //Если условие if выполнилось (т.е., символы совпадают), переменная match_indicator устанавливается в значение 1. Это означает, что было обнаружено совпадение между символом из str1 и каким-то символом из str2.
         }
         scanPtr++; //scanPtr++ необходим для того, чтобы обеспечить продвижение по строке str2 и систематическую проверку каждого её символа на совпадение с текущим символом str1. Это ключевой элемент логики поиска в функциях, работающих со строками, и обеспечивает полное и эффективное сравнение строк.


      }

      
      
      
      if (!match_indicator) { //Строка кода if (!match_indicator) { используется для проверки условия в рамках алгоритма, который определяет наличие или отсутствие совпадения символов между двумя строками. В этом контексте, match_indicator является переменной типа int, которая действует как флаг, сигнализируя о нахождении или не нахождении совпадения между символом из первой строки (str1) и любым из символов второй строки (str2). Давайте разберем, что делает эта проверка и как она работает:


      //Эта переменная используется для индикации наличия совпадения. Обычно она устанавливается в 0 (ложь) в начале каждой новой итерации проверки текущего символа из str1. Если в процессе перебора символов str2 находится совпадающий символ, match_indicator устанавливается в 1 (истина).

      //Назначение условия: В контексте функции, для подсчета количества начальных символов в str1, которые не встречаются в str2 (как в функции strcspn), этот блок if может использоваться для увеличения счетчика, который отслеживает, сколько символов было проверено без обнаружения совпадения.

         length_before_first_match++; // Увеличиваем счетчик, т.к. совпадение не найдено
      }
      
      
      
      
      
      str1++;  // Переход к следующему символу в str1 //если убрать это условие цикл попросту не будет работать

  }


  return length_before_first_match; //Возвращается несовпавшая длина 
  
  //Это переменная типа s21_size_t, которая инкрементируется каждый раз, когда символ из str1 проверяется против всех символов в str2 и не находится ни одного совпадения. Как только обнаруживается совпадение, или проверяются все символы в str1 без обнаружения совпадений, функция возвращает текущее значение length_before_first_match.
}



/*
  Рассмотрим наглядный пример, который поможет понять принцип работы функции `strcspn()`.

### Пример:
Предположим, у нас есть две строки:
- `str1 = "abcdefg"`
- `str2 = "xyz"`

Мы хотим найти длину начального сегмента строки `str1`, который не содержит ни одного символа из строки `str2`.

### Шаги работы функции `strcspn()`

1. **Инициализация:**
   - `count = 0`

2. **Внешний цикл:**
   - `s1` указывает на первый символ строки `str1` (`'a'`).

3. **Вложенный цикл:**
   - `s2` указывает на первый символ строки `str2` (`'x'`).
   - Проверка `if (*s1 == *s2)` не выполняется, так как `'a'` не равно `'x'`.
   - `s2` указывает на второй символ строки `str2` (`'y'`).
   - Проверка `if (*s1 == *s2)` не выполняется, так как `'a'` не равно `'y'`.
   - `s2` указывает на третий символ строки `str2` (`'z'`).
   - Проверка `if (*s1 == *s2)` не выполняется, так как `'a'` не равно `'z'`.

4. **Увеличение счетчика:**
   - `count` увеличивается на 1 (`count = 1`).
   - `s1` указывает на второй символ строки `str1` (`'b'`).

5. **Повторение шагов 3-4:**
   - Вложенный цикл проходит по всем символам строки `str2` для символа `'b'` строки `str1`.
   - `count` увеличивается на 1 (`count = 2`).
   - `s1` указывает на третий символ строки `str1` (`'c'`).

6. **Продолжение процесса:**
   - Вложенный цикл продолжается для каждого символа строки `str1` (`'c'`, `'d'`, `'e'`, `'f'`, `'g'`), пока не будет достигнут конец строки.
   - `count` последовательно увеличивается до 7 (`count = 7`), так как ни один символ из `str2` не встречается в `str1`.

7. **Завершение:**
   - Внешний цикл завершается, так как `s1` достигает конца строки `str1`.
   - Возвращается значение `count`, которое равно 7.

### Визуализация

- `str1: "abcdefg"`
- `str2: "xyz"`

|  Шаг  | `s1` указывает на | Сравнение с `str2` | `count` |
|-------|-------------------|--------------------|---------|
|   1   | `'a'`             | нет совпадения     |   1     |
|   2   | `'b'`             | нет совпадения     |   2     |
|   3   | `'c'`             | нет совпадения     |   3     |
|   4   | `'d'`             | нет совпадения     |   4     |
|   5   | `'e'`             | нет совпадения     |   5     |
|   6   | `'f'`             | нет совпадения     |   6     |
|   7   | `'g'`             | нет совпадения     |   7     |

Итог: функция `strcspn` возвращает 7, так как все 7 символов строки `str1` не содержат ни одного символа из строки `str2`.

Если бы строка `str2` содержала символ, который встречается в строке `str1`, например, если бы `str2` была `"e"`, то функция вернула бы 4, так как первый символ из `str2` найден в `str1` на пятой позиции (считая с нуля), и предшествует ему 4 символа (`"abcd"`).

Надеюсь, этот пример помог вам понять принцип работы функции `strcspn()`!

*/





/*

Функция `s21_strcspn`, которую вы описали, возвращает значение, хранящееся в переменной `length_before_first_match`. Это значение представляет собой количество символов начального сегмента строки `str1`, в котором не содержится ни одного из символов, присутствующих в строке `str2`. Давайте разберем, что это значит и как работает эта функция:

### Что возвращает функция?

- **`length_before_first_match`**: Это переменная типа `s21_size_t`, которая инкрементируется каждый раз, когда символ из `str1` проверяется против всех символов в `str2` и не находится ни одного совпадения. Как только обнаруживается совпадение, или проверяются все символы в `str1` без обнаружения совпадений, функция возвращает текущее значение `length_before_first_match`.

### Как это работает?

- Функция начинает с `length_before_first_match = 0` и перебирает каждый символ в `str1`.
- Для каждого символа в `str1`, она использует вложенный цикл, чтобы сравнить этот символ с каждым символом в `str2`.
- Если символ из `str1` совпадает с любым символом из `str2`:
  - Функция прекращает дальнейшую проверку и возвращает количество символов из `str1`, которые были проверены до первого совпадения.
- Если символ из `str1` не совпадает ни с одним символом из `str2`, то `length_before_first_match` увеличивается на 1.
- Этот процесс повторяется, пока не будут проверены все символы в `str1` или пока не будет найдено совпадение.

### Пример

Предположим, у нас есть две строки:
- `str1` = "abcdefg"
- `str2` = "xyz"

Функция `s21_strcspn(str1, str2)` будет перебирать символы в `str1` ("abcdefg") и сравнивать каждый символ с символами в `str2` ("xyz"). Поскольку нет совпадающих символов между `str1` и `str2`, функция пройдет через все символы в `str1` и в конечном итоге вернет значение 7, что является длиной `str1`.

### Заключение

Возвращаемое значение функции `s21_strcspn` показывает, насколько длинный начальный сегмент строки `str1` может быть сформирован без включения любых символов из строки `str2`. Это полезно для различных задач обработки и анализа строк, где необходимо узнать, содержатся ли символы одной строки в другой с самого начала.
*/
#include "../s21_string.h"




//Функция strpbrk() в языке программирования C используется для поиска первого вхождения любого символа из набора символов в строке

//Отличия strpbrk() от strcspn():

//strpbrk завершает работу при нахождении первого совпадения.
//strcspn завершает работу при нахождении первого несовпадения, после чего возвращает длину сегмента.

/*
Функция strpbrk() расшифровывается как "string pointer break".

Вот разбивка:

str: сокращение от "string" (строка).
p: сокращение от "pointer" (указатель).
brk: сокращение от "break" (разрыв, остановка).
Вместе это означает, что функция ищет и возвращает указатель на место в строке, где найден первый символ из заданного набора, тем самым "останавливая" поиск при первом совпадении.
*/




char *s21_strpbrk(const char *str1, const char *str2) {
    
    //str1 — строка, в которой функция будет искать.
    //str2 — строка, содержащая символы, которые мы ищем в str1.

    char *found_char_ptr = s21_NULL; //указатель, который будет использоваться для хранения адреса (указателя на) символа в строке str1.

    //Переменная found_char_ptr инициализируется значением s21_NULL
    
    //Содержит указатель на первый символ из строки str1, который совпадает с любым символом из строки str2. Если таких совпадений не найдено, переменная будет содержать NULL.
    
    int str1_length = s21_strlen(str1);
    int str2_length = s21_strlen(str2);
    int found = 0;

    // Внешний цикл проходит по строке str1
    for (int i = 0; i < str1_length && !found; i++) { //!found: Логическое отрицание переменной found. То есть цикл продолжается, пока переменная found имеет значение 0 (или false). Переменная found используется как флаг, чтобы остановить дальнейшие итерации, когда совпадение найдено.


        // Внутренний цикл проходит по строке str2
        for (int j = 0; j < str2_length && !found; j++) {
            if (str1[i] == str2[j]) {

                found_char_ptr = (char *)(str1 + i); //как только находится совпавший символ i смещает указатель str1 на i позиций вперед, в соответствии с количеством итераций


                /* Почему происходит привдение типов ?

                Типы данных:

                str1 имеет тип const char *, что означает, что указатель str1 указывает на неизменяемые данные.

                found_char_ptr объявлена как char *, что означает, что указатель может указывать на изменяемые данные.
                
                Проблема без приведения типов:

                Когда вы пытаетесь присвоить указатель типа const char * (то есть результат str1 + i) переменной типа char *, компилятор выдает предупреждение, потому что это действие может привести к изменению данных, которые изначально должны быть неизменяемыми. Это называется потерей квалификатора const.
                
                Решение с приведением типов:

                Приведение типа (char *)(str1 + i) явно указывает компилятору, что вы сознательно хотите игнорировать квалификатор const и работать с указателем как с char *. Это устраняет предупреждение компилятора, так как компилятор теперь понимает, что вы берете на себя ответственность за возможные последствия изменения данных.
                
                Сохраняется ли константность данных?
                
                Нет, приведение типов не сохраняет константность данных. Приведение типа const char * к char * снимает квалификатор const, позволяя изменять данные, на которые указывает указатель. Поэтому нужно использовать это с осторожностью и понимать возможные риски.
                
                */


                found = 1; // Устанавливаем флаг найденного совпадения и останаливает цикл
            }
        }
    }
    return found_char_ptr; //Функция s21_strpbrk возвращает указатель на первый символ в строке str1, который совпадает с любым символом из строки str2. Если такого символа не найдено, функция возвращает NULL.
}


// версия от 30 июня
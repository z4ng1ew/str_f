#include "../s21_string.h"

/*
Функция strerror() в языке программирования Си используется для получения текста сообщения об ошибке, соответствующего коду ошибки. Эта функция принимает в качестве аргумента целое число, представляющее код ошибки (обычно это глобальная переменная errno), и возвращает указатель на строку с описанием этой ошибки.
*/

//Эти макросы #define используются для определения констант, которые применяются в функции s21_strerror для обработки и отображения сообщений об ошибках. Вот объяснение каждого из них:

#define MAX_ERR_MESSAGES_INDEX 134 //все сообщения об ошибках учитывая нуль терминатор  - \0 
// Этот макрос определяет максимальное значение кода ошибки, для которого имеется описание в массиве err_messages_arr

//В функции s21_strerror этот макрос используется для проверки, находится ли предоставленный код ошибки в допустимом диапазоне. Если код ошибки больше или равен MAX_ERR_MESSAGES_INDEX, считается, что он выходит за пределы диапазона известных ошибок.


#define MIN_ERR_MESSAGES_INDEX -1 //Этот макрос определяет минимальное значение кода ошибки, которое считается допустимым.

// Использование: В функции s21_strerror этот макрос также используется для проверки, находится ли предоставленный код ошибки в допустимом диапазоне. Если код ошибки меньше или равен MIN_ERR_MESSAGES_INDEX, считается, что он выходит за пределы диапазона известных ошибок.

// Макрос инициализированн цифрой -1 потомучто массив начинается с 0 и соответственно индекс самой первой оишибки равен 0.

#define ERR_CODE_OUTSIDE  "Unknown error "

/*
Этот макрос определяет строку, которая используется в сообщении об ошибке, если код ошибки находится за пределами допустимого диапазона.

Использование: В случае, если предоставленный код ошибки выходит за пределы диапазона, функция s21_strerror формирует сообщение об "неизвестной ошибке" с использованием этого макроса. Строка ERROR используется как префикс для сообщения, которое будет включать в себя и код ошибки.

*/


//всего 133 строк 

static const char *err_messages_arr[] = { // err_messages_arr - это массив строк, каждая из которых представляет текстовое описание определённого кода ошибки. Этот массив используется для того, чтобы преобразовывать числовые коды ошибок в человекочитаемые строки.

/*
Почему массив объявлен статическим (static)?
Объявление массива err_messages_arr как статического имеет несколько важных последствий:

Видимость внутри файла: Ключевое слово static ограничивает область видимости массива err_messages_arr пределами текущего файла. Это означает, что другие файлы в проекте не смогут получить к нему доступ напрямую, даже если они включают этот файл. Это помогает избежать конфликтов имен и несанкционированного доступа к данным.

Инициализация только один раз: Статические переменные и массивы инициализируются только один раз и сохраняют своё значение между вызовами функций. В данном случае, массив err_messages_arr инициализируется при загрузке программы и остаётся в памяти до завершения программы.

Постоянное расположение в памяти: Статические переменные хранятся в области памяти, выделенной для статических данных, что обеспечивает их постоянное местоположение на протяжении всего времени выполнения программы. Это важно для таких данных, как м
*/

//Строковые литералы в языке программирования C — это последовательности символов, заключенные в двойные кавычки, которые представляют собой неизменяемые строки. Они используются для задания фиксированных строковых значений в коде. Строковые литералы являются массивами символов, которые завершаются нулевым символом \0, обозначающим конец строки.

//Строковый литерал в C имеет тип const char[], что означает, что он является массивом константных символов. Когда строковый литерал используется в выражении, он автоматически преобразуется в указатель на первый символ строки (const char *).



//Неизменяемость данных (const):

// Ключевое слово const указывает на то, что данные, на которые указывают элементы массива, не могут быть изменены. Это делает массив неизменяемым, что защищает строковые литералы от случайного изменения.

// Объявление массива константным гарантирует, что строки не будут модифицированы в ходе выполнения программы, что особенно важно для строковых литералов, которые обычно хранятся в защищенной от записи памяти.

    "Success",
    "Operation not permitted",
    "No such file or directory",
    "No such process",
    "Interrupted system call",
    "Input/output error",
    "No such device or address",
    "Argument list too long",
    "Exec format error",
    "Bad file descriptor",
    "No child processes",
    "Resource temporarily unavailable",
    "Cannot allocate memory",
    "Permission denied",
    "Bad address",
    "Block device required",
    "Device or resource busy",
    "File exists",
    "Invalid cross-device link",
    "No such device",
    "Not a directory",
    "Is a directory",
    "Invalid argument",
    "Too many open files in system",
    "Too many open files",
    "Inappropriate ioctl for device",
    "Text file busy",
    "File too large",
    "No space left on device",
    "Illegal seek",
    "Read-only file system",
    "Too many links",
    "Broken pipe",
    "Numerical argument out of domain",
    "Numerical result out of range",
    "Resource deadlock avoided",
    "File name too long",
    "No locks available",
    "Function not implemented",
    "Directory not empty",
    "Too many levels of symbolic links",
    "Unknown error 41",
    "No message of desired type",
    "Identifier removed",
    "Channel number out of range",
    "Level 2 not synchronized",
    "Level 3 halted",
    "Level 3 reset",
    "Link number out of range",
    "Protocol driver not attached",
    "No CSI structure available",
    "Level 2 halted",
    "Invalid exchange",
    "Invalid request descriptor",
    "Exchange full",
    "No anode",
    "Invalid request code",
    "Invalid slot",
    "Unknown error 58",
    "Bad font file format",
    "Device not a stream",
    "No data available",
    "Timer expired",
    "Out of streams resources",
    "Machine is not on the network",
    "Package not installed",
    "Object is remote",
    "Link has been severed",
    "Advertise error",
    "Srmount error",
    "Communication error on send",
    "Protocol error",
    "Multihop attempted",
    "RFS specific error",
    "Bad message",
    "Value too large for defined data type",
    "Name not unique on network",
    "File descriptor in bad state",
    "Remote address changed",
    "Can not access a needed shared library",
    "Accessing a corrupted shared library",
    ".lib section in a.out corrupted",
    "Attempting to link in too many shared libraries",
    "Cannot exec a shared library directly",
    "Invalid or incomplete multibyte or wide character",
    "Interrupted system call should be restarted",
    "Streams pipe error",
    "Too many users",
    "Socket operation on non-socket",
    "Destination address required",
    "Message too long",
    "Protocol wrong type for socket",
    "Protocol not available",
    "Protocol not supported",
    "Socket type not supported",
    "Operation not supported",
    "Protocol family not supported",
    "Address family not supported by protocol",
    "Address already in use",
    "Cannot assign requested address",
    "Network is down",
    "Network is unreachable",
    "Network dropped connection on reset",
    "Software caused connection abort",
    "Connection reset by peer",
    "No buffer space available",
    "Transport endpoint is already connected",
    "Transport endpoint is not connected",
    "Cannot send after transport endpoint shutdown",
    "Too many references: cannot splice",
    "Connection timed out",
    "Connection refused",
    "Host is down",
    "No route to host",
    "Operation already in progress",
    "Operation now in progress",
    "Stale file handle",
    "Structure needs cleaning",
    "Not a XENIX named type file",
    "No XENIX semaphores available",
    "Is a named type file",
    "Remote I/O error",
    "Disk quota exceeded",
    "No medium found",
    "Wrong medium type",
    "Operation canceled",
    "Required key not available",
    "Key has expired",
    "Key has been revoked",
    "Key was rejected by service",
    "Owner died",
    "State not recoverable",
    "Operation not possible due to RF-kill",
    "Memory page has hardware error"
};

/*Реализация функции s21_strerror, которую вы видете, является пользовательской версией стандартной функции strerror, предназначенной для получения текстового описания ошибки на основе её числового кода. Давайте разберем её подробнее.*/

char *s21_strerror(int errnum) { //Функция s21_strerror предназначена для получения текстового описания ошибки на основе её числового кода. Она работает аналогично стандартной функции strerror.

  static char error_message_result[300] = {'\0'}; // это статический массив символов, который используется для хранения результирующей строки. Статическая переменная инициализируется только один раз и сохраняет своё значение между вызовами функции. Инициализируется нулевым символом, чтобы гарантировать, что строка начинается пустой.

  if (errnum >= MAX_ERR_MESSAGES_INDEX || errnum <= MIN_ERR_MESSAGES_INDEX) { //Проверяет, превышает ли значение errnum максимальный и минимальный допустимый индекс массива описаний ошибок (err_messages_arr).


   s21_sprintf(error_message_result, "%s%d", ERR_CODE_OUTSIDE, errnum);

   //Входными данными для функции s21_sprintf являются:
   // 1) error_message_result: Указатель на массив символов, куда будет записан отформатированный результат.
   // 2) "%s%d": Строка формата, которая определяет, как следует форматировать данные.
   // 3) ERR_CODE_OUTSIDE: Строка, которая будет подставлена на место спецификатора %s.
   // 4) errnum: Целое число, которое будет подставлено на место спецификатора %d.

   //Первый спецификатор %s:
      // ERR_CODE_OUTSIDE (строка "Unknown error ") подставляется на место %s.
      // В промежуточный результат записывается "Unknown error ".
   
   //Второй спецификатор %d:
      // Значение переменной errnum подставляется на место %d.
      // Если, например, errnum равно 422, то промежуточный результат обновляется до "Unknown error 422".

   //Отформатированная строка "Unknown error 422" записывается в массив error_message_result. //массив error_message_result будет содержать строку "Unknown error 42".

   //Процесс форматирования строки с использованием sprintf включает анализ строки формата, подстановку аргументов на места спецификаторов и запись отформатированного результата в указанный массив символов. В вашем примере функция s21_sprintf форматирует строку, подставляя строку и целое число на соответствующие места спецификаторов %s и %d, и записывает результат в массив error_message_result.

   //!!! Данный принцип работы sprint очень схож с принципом работы printf(), но только в отличие от него он записывает результат не в терминал а в массиив.  //В контексте функции s21_strerror, задача состоит в том, чтобы сформировать текстовое сообщение об ошибке и вернуть его в виде строки. Вывод этого сообщения на экран не соответствует требованиям задачи. Необходимо сохранить сформированное сообщение в массиве символов, чтобы его можно было вернуть вызывающей функции и использовать в дальнейшем. //Функция printf используется для вывода форматированной строки на стандартный вывод (например, на экран), тогда как sprintf используется для записи форматированной строки в указанный массив символов. Эти функции имеют схожий синтаксис и форматирование, но различаются в целях и способах использования.


  } else {



   s21_strncpy(error_message_result, err_messages_arr[errnum], 299); //Использование 255 символов при копировании в буфер размером 256 байтов обусловлено необходимостью оставления места для нуль-терминатора. Это гарантирует, что результирующая строка будет правильно нуль-терминирована, предотвращая потенциальные ошибки при работе со строками в языке C.
  } //Копирование строки:s21_strncpy копирует до 299 символов из строки-источника err_messages_arr[errnum] в массив назначения error_message_result.

  // Если длина строки-источника меньше 299 символов, оставшиеся места в массиве назначения будут заполнены нуль-терминаторами (\0).


   //Обеспечение нуль-терминированности: Копирование 299 символов оставляет один символ для нуль-терминатора, чтобы гарантировать, что результирующая строка будет правильно завершена.

   //Строка "Input/output error" будет скопирована в error_message_result. Если длина строки "Input/output error" составляет 17 символов, то оставшиеся места в error_message_result будут заполнены нуль-терминаторами.

  return error_message_result; //В этой строке кода возвращается указатель на строку, содержащую текстовое сообщение об ошибке
}




/*

`#define` — это директива препроцессора в языке программирования C (и C++), которая используется для определения макросов. Макросы позволяют задавать символические имена для констант или фрагментов кода, которые затем могут использоваться в программе. При компиляции, препроцессор заменяет все вхождения макроса его определением.

### Пример использования `#define`

1. **Определение констант:**

```c
#define PI 3.14159
#define MAX_BUFFER_SIZE 1024
```

- **PI**: Везде, где в коде встречается `PI`, препроцессор заменяет это на `3.14159`.
- **MAX_BUFFER_SIZE**: Везде, где в коде встречается `MAX_BUFFER_SIZE`, препроцессор заменяет это на `1024`.

2. **Определение макросов с аргументами:**

```c
#define SQUARE(x) ((x) * (x))
```

- **SQUARE(x)**: Макрос с аргументом `x`, который вычисляет квадрат числа `x`. Везде, где в коде встречается `SQUARE(число)`, препроцессор заменяет это на `((число) * (число))`.

### Как это работает

Когда компилятор C компилирует программу, сначала выполняется этап препроцессинга. На этом этапе препроцессор обрабатывает директивы `#define` и заменяет все вхождения макросов их значениями или кодом.

### Пример кода с использованием `#define`

```c
#include <stdio.h>

#define PI 3.14159
#define AREA_OF_CIRCLE(radius) (PI * (radius) * (radius))

int main() {
    double radius = 5.0;
    double area = AREA_OF_CIRCLE(radius);
    printf("Area of circle with radius %.2f is %.2f\n", radius, area);
    return 0;
}
```

В этом примере:

- `#define PI 3.14159` определяет макрос `PI` со значением `3.14159`.
- `#define AREA_OF_CIRCLE(radius) (PI * (radius) * (radius))` определяет макрос для вычисления площади круга.
- В `main` функция вычисляет площадь круга с радиусом `5.0` и выводит результат.

### Преимущества использования `#define`

1. **Удобочитаемость кода**: Макросы позволяют использовать описательные имена вместо магических чисел или строк, что делает код более понятным.
2. **Легкость изменения**: Изменение значения макроса в одном месте автоматически изменяет его во всех местах использования.
3. **Кодогенерация**: Макросы могут быть использованы для генерации кода, например, определения инлайновых функций.

### Недостатки использования `#define`

1. **Отсутствие типобезопасности**: Макросы не имеют типов, что может привести к ошибкам, которые компилятор не сможет обнаружить.
2. **Трудности отладки**: Поскольку макросы заменяются на этапе препроцессинга, ошибки, связанные с макросами, могут быть сложнее отлаживать.
3. **Неожиданное поведение**: Некорректное использование макросов (например, забытые скобки) может привести к неожиданному поведению программы.

### Заключение

`#define` — это мощный инструмент в языке C, который позволяет создавать константы и макросы, улучшая удобочитаемость и управляемость кода. Однако важно использовать его с осторожностью, чтобы избежать возможных проблем с отладкой и безопасностью типов.
*/


/*
Директива в языке программирования C — это команда препроцессору, которая выполняется до стадии компиляции кода. Директивы препроцессора начинаются с символа `#` и включают такие команды, как `#define`, `#include`, `#if`, `#endif`, `#ifdef`, `#ifndef`, и другие. Эти команды управляют тем, как препроцессор обрабатывает исходный код перед его компиляцией.

### Примеры директив препроцессора

1. **`#define`**:
   - Определяет макрос или константу.
   ```c
   #define PI 3.14159
   #define SQUARE(x) ((x) * (x))
   ```

2. **`#include`**:
   - Включает содержимое другого файла в текущий файл исходного кода.
   ```c
   #include <stdio.h>
   #include "myheader.h"
   ```

3. **`#if`, `#ifdef`, `#ifndef`, `#else`, `#elif`, `#endif`**:
   - Управляют условной компиляцией кода.
   ```c
   #define DEBUG

   #ifdef DEBUG
   printf("Debug mode is enabled\n");
   #endif

   #if defined(DEBUG) && !defined(NDEBUG)
   printf("Debug mode is strictly enabled\n");
   #else
   printf("Debug mode is disabled\n");
   #endif
   ```

4. **`#undef`**:
   - Отменяет ранее определённый макрос.
   ```c
   #define PI 3.14159
   #undef PI
   ```

5. **`#error` и `#warning`**:
   - Выводят сообщения об ошибках или предупреждениях во время препроцессинга.
   ```c
   #ifdef DEBUG
   #error Debug mode is not supported
   #endif
   ```

6. **`#pragma`**:
   - Директива для передачи специальных инструкций компилятору.
   ```c
   #pragma once // Предотвращает повторное включение файла
   ```

### Как работают директивы препроцессора

Когда компилятор C начинает обрабатывать исходный код, первым этапом является препроцессинг. На этом этапе препроцессор читает исходный код и выполняет директивы препроцессора. Это может включать:

- Замена макросов на их определения.
- Включение содержимого других файлов (заголовочных файлов).
- Условная компиляция определённых частей кода.
- Вывод сообщений об ошибках или предупреждениях.
- Выполнение других команд, которые могут повлиять на компиляцию.

### Пример работы директив препроцессора

Рассмотрим пример кода с директивами препроцессора:

```c
#include <stdio.h>

#define PI 3.14159
#define SQUARE(x) ((x) * (x))

int main() {
    double radius = 5.0;
    double area = PI * SQUARE(radius);
    printf("Area of circle with radius %.2f is %.2f\n", radius, area);
    return 0;
}
```

Во время препроцессинга:

1. **`#include <stdio.h>`**: Препроцессор включит содержимое заголовочного файла `stdio.h` в этот файл.
2. **`#define PI 3.14159`**: Все вхождения `PI` будут заменены на `3.14159`.
3. **`#define SQUARE(x) ((x) * (x))`**: Все вхождения `SQUARE(что-то)` будут заменены на `((что-то) * (что-то))`.

После этого этапа компилятор получит преобразованный исходный код, который затем будет компилирован в исполняемый файл.

### Заключение

Директивы препроцессора — это мощный инструмент в языке C, позволяющий управлять процессом компиляции на уровне исходного кода. Они используются для создания макросов, управления включением файлов, условной компиляции и выполнения других задач, которые помогают сделать код более гибким и управляемым.

*/



/*
Строковые литералы в языке программирования C — это последовательности символов, заключенные в двойные кавычки, которые представляют собой неизменяемые строки. Они используются для задания фиксированных строковых значений в коде. Строковые литералы являются массивами символов, которые завершаются нулевым символом `\0`, обозначающим конец строки.

### Примеры строковых литералов

```c
"Hello, World!"
"Sample string"
"12345"
""
```

### Характеристики строковых литералов

1. **Неизменяемость**:
   - Строковые литералы неизменяемы, что означает, что их содержимое не должно изменяться. Это связано с тем, что строковые литералы хранятся в области памяти, защищенной от записи, часто называемой сегментом констант.

2. **Автоматическое добавление нулевого символа**:
   - Строковые литералы автоматически завершаются нулевым символом `\0`. Это позволяет функциям стандартной библиотеки C, таким как `printf`, `strcpy` и `strlen`, правильно работать с этими строками.

3. **Тип данных**:
   - Строковый литерал в C имеет тип `const char[]`, что означает, что он является массивом константных символов. Когда строковый литерал используется в выражении, он автоматически преобразуется в указатель на первый символ строки (`const char *`).

### Примеры использования строковых литералов

```c
#include <stdio.h>

int main() {
    const char *greeting = "Hello, World!";
    printf("%s\n", greeting); // Вывод: Hello, World!
    
    printf("Length of greeting: %lu\n", strlen(greeting)); // Вывод: Length of greeting: 13
    
    return 0;
}
```

### Хранение строковых литералов в памяти

Строковые литералы обычно хранятся в сегменте констант памяти программы. Этот сегмент является частью исполняемого файла программы и защищен от записи, что предотвращает изменение строковых литералов во время выполнения программы.

### Пример работы с строковыми литералами и указателями

Рассмотрим пример массива строковых литералов, где каждый элемент массива является указателем на строку:

```c
#include <stdio.h>

static const char *errorMessages[] = {
    "Success",
    "Operation not permitted",
    "No such file or directory",
    "No such process"
};

int main() {
    for (int i = 0; i < 4; i++) {
        printf("Error %d: %s\n", i, errorMessages[i]);
    }
    return 0;
}
```

В этом примере:

- `errorMessages` — это массив указателей на строковые литералы.
- Каждый элемент массива `errorMessages` указывает на строковый литерал, такой как `"Success"` или `"Operation not permitted"`.
- Цикл `for` проходит по каждому элементу массива и выводит соответствующее сообщение об ошибке.

### Заключение

Строковые литералы являются важным элементом языка программирования C, предоставляющим простой способ задания неизменяемых строк. Они хранятся в защищенной области памяти и автоматически завершаются нулевым символом. Использование строковых литералов в сочетании с указателями позволяет эффективно работать с текстовыми данными и упрощает их обработку в программах на языке C.

*/



/*

Функция `printf` используется для вывода форматированной строки на стандартный вывод (например, на экран), тогда как `sprintf` используется для записи форматированной строки в указанный массив символов. Эти функции имеют схожий синтаксис и форматирование, но различаются в целях и способах использования.

### Отличия `printf` и `sprintf`

1. **Цель использования**:
   - **`printf`**: Выводит форматированную строку непосредственно на стандартный вывод (экран).
   - **`sprintf`**: Записывает форматированную строку в указанный массив символов.

2. **Пример использования `printf`**:
   ```c
   printf("%s%d", ERR_CODE_OUTSIDE, errnum);
   ```
   - Эта строка выведет текст `"Unknown error 42"` (если `ERR_CODE_OUTSIDE` равно `"Unknown error "` и `errnum` равно `42`) непосредственно на экран.

3. **Пример использования `sprintf`**:
   ```c
   sprintf(error_message_result, "%s%d", ERR_CODE_OUTSIDE, errnum);
   ```
   - Эта строка запишет текст `"Unknown error 42"` в массив `error_message_result`.

### Почему не подходит `printf` в данном случае

В контексте функции `s21_strerror`, задача состоит в том, чтобы сформировать текстовое сообщение об ошибке и вернуть его в виде строки. Вывод этого сообщения на экран не соответствует требованиям задачи. Необходимо сохранить сформированное сообщение в массиве символов, чтобы его можно было вернуть вызывающей функции и использовать в дальнейшем.

### Пример функции `s21_strerror`

```c
char *s21_strerror(int errnum) {
  static char error_message_result[256] = {'\0'};

  if (errnum >= MAX_ERR_MESSAGES_INDEX || errnum <= MIN_ERR_MESSAGES_INDEX) {
    s21_sprintf(error_message_result, "%s%d", ERR_CODE_OUTSIDE, errnum);
  } else {
    s21_strncpy(error_message_result, err_messages_arr[errnum], 255);
  }

  return error_message_result;
}
```

### Объяснение, почему используется `sprintf`

1. **Запись в массив**:
   - Функция `s21_sprintf` записывает форматированную строку в массив `error_message_result`, чтобы затем вернуть её в виде строки. Это позволяет функции `s21_strerror` формировать сообщение об ошибке, которое можно использовать в любом месте программы.

2. **Возвращаемое значение**:
   - Возвращаемое значение функции `s21_strerror` — это указатель на строку, содержащую сообщение об ошибке. Использование `printf` для вывода сообщения на экран не позволяет сохранить и вернуть это сообщение.

3. **Удобство использования**:
   - `sprintf` позволяет форматировать строку с использованием различных спецификаторов формата и записывать результат в указанный массив символов, что делает её идеальным выбором для задачи формирования строк.

### Заключение

Использование `sprintf` в функции `s21_strerror` обусловлено необходимостью записать форматированную строку в массив символов, чтобы затем вернуть её вызывающей функции. `printf` предназначен для вывода на экран и не подходит для этой задачи, так как не предоставляет возможности сохранить сформированное сообщение для последующего использования.
*/
#include "../s21_string.h"

int s21_memcmp(const void *str1, const void *str2, s21_size_t n) {
//Объявляется функция s21_memcmp, которая принимает три аргумента:

  // const void *str1: указатель на первую область памяти.
  // const void *str2: указатель на вторую область памяти. 
  // s21_size_t n: количество байт для сравнения.


  // !!  Преобразование из const void * позволяет функции работать с любыми типами данных. !!


  int compare_res = 0; //Переменная compare_res инициализируется нулем. Она будет использоваться для хранения результата сравнения.


  const unsigned char *ptr_byte1 = str1; //указатель на первую область памяти.
  const unsigned char *ptr_byte2 = str2; //указатель на вторую область памяти.

  //здесь мы передаём значения от str к const unsigned char - потомучто так надёжнее, что бы в прцеесе выполнения операции значение не поменялось

  //const является квалификатором в языке программирования C (и C++). Квалификаторы — это ключевые слова, которые используются для модификации характеристик типов данных. В случае const, он указывает, что значение переменной или данные, на которые указывает указатель, не могут быть изменены после их инициализации.

  //Использование const указывает на то, что данные, на которые указывает указатель, не могут быть изменены через этот указатель. Это делает код более безопасным и читаемым, гарантируя, что исходные данные не будут случайно изменены в процессе выполнения функции.


  // Преимущества использования unsigned char:

  // Беззнаковое сравнение: Использование unsigned char гарантирует, что все байты будут рассматриваться как беззнаковые значения от 0 до 255. Это устраняет проблемы, связанные с интерпретацией знаковых байтов, где значения от -128 до 127 могут быть неправильно сопоставлены.

  //Функция memcmp сравнивает области памяти побайтно. Тип unsigned char используется для того, чтобы избежать проблем с интерпретацией знаковых байтов. Это важно, поскольку сравнение байтовых данных должно происходить на уровне 8-битных значений, а не 8-битных знаковых чисел.

  // Точное сравнение: При побайтовом сравнении каждый байт сравнивается независимо, что позволяет точно определить, какой из байтов первого встретился различным
  
  for (s21_size_t i = 0; i < n && compare_res == 0; i++) {


  //i < n: цикл продолжается, пока i меньше n, что гарантирует, что цикл выполнится не более чем n раз.

  //compare_res == 0: цикл продолжается, пока compare_res равно 0. Если compare_res становится ненулевым, это значит, что найдено различие, и цикл прекращается.

  //compare_res инициализируется значением 0, что означает, что до начала цикла предполагается, что массивы идентичны.

  ///Внутри цикла каждый байт ptr_byte1[i] сравнивается с соответствующим байтом ptr_byte2[i].

    if (ptr_byte1[i] != ptr_byte2[i]) { //Если найдено различие (ptr_byte1[i] != ptr_byte2[i]), переменная compare_res получает значение разности этих байтов (ptr_byte1[i] - ptr_byte2[i]).
      compare_res = ptr_byte1[i] - ptr_byte2[i]; //Как только compare_res становится ненулевым, цикл прекращается, так как условие compare_res == 0 больше не выполняется.
    };

  }

  return compare_res; //Функция s21_memcmp возвращает значение compare_res, потому что это значение определяет результат сравнения двух областей памяти. Этот результат может использоваться для различных целей, таких как сортировка, проверка на равенство или определение порядка строк
}





/*

Использование типа `unsigned char` для сравнения данных побайтно в функции `memcmp` означает, что каждая часть данных (каждый байт) будет сравниваться независимо от других байтов. Вот как этот процесс работает более подробно:

### Объяснение побайтового сравнения

#### 1. Побайтовый доступ
- **Преобразование указателей:** При преобразовании указателей `str1` и `str2` к типу `const unsigned char *`, мы получаем возможность обращаться к данным побайтно. Тип `unsigned char` представляет собой 8-битное беззнаковое значение, что идеально подходит для побайтового доступа.

```c
const unsigned char *ptr_byte1 = (const unsigned char *)mem1;
const unsigned char *ptr_byte2 = (const unsigned char *)mem2;
```

#### 2. Цикл сравнения
- **Итерация:** Цикл проходит по каждому байту из областей памяти `mem1` и `mem2` до `n` байт или пока не будет найдено различие.

```c
for (s21_size_t i = 0; i < n && compare_res == 0; i++) {
```

#### 3. Сравнение байтов
- **Проверка равенства:** На каждой итерации цикла проверяется, равны ли текущие байты в `ptr_byte1` и `ptr_byte2`.

```c
if (ptr_byte1[i] != ptr_byte2[i])
```

- **Вычисление разницы:** Если байты не равны, вычисляется разница между ними и сохраняется в переменной `compare_res`.

```c
compare_res = ptr_byte1[i] - ptr_byte2[i];
```

#### 4. Преимущества использования unsigned char

- **Беззнаковое сравнение:** Использование `unsigned char` гарантирует, что все байты будут рассматриваться как беззнаковые значения от 0 до 255. Это устраняет проблемы, связанные с интерпретацией знаковых байтов, где значения от -128 до 127 могут быть неправильно сопоставлены.
- **Точное сравнение:** При побайтовом сравнении каждый байт сравнивается независимо, что позволяет точно определить, какой из байтов первого встретился различным.

### Пример

Предположим, что у нас есть два массива байтов:

```c
const unsigned char arr1[] = {0x48, 0x65, 0x6C, 0x6C, 0x6F}; // "Hello"
const unsigned char arr2[] = {0x48, 0x65, 0x6C, 0x6C, 0x6F}; // "Hello"
s21_size_t n = 5;
int compare_res = 0;

const unsigned char *ptr_byte1 = arr1;
const unsigned char *ptr_byte2 = arr2;

for (s21_size_t i = 0; i < n && compare_res == 0; i++) {
    if (ptr_byte1[i] != ptr_byte2[i]) {
        compare_res = ptr_byte1[i] - ptr_byte2[i];
    }
}
```

В этом примере:
- На каждой итерации сравниваются байты `ptr_byte1[i]` и `ptr_byte2[i]`.
- Поскольку массивы идентичны, `compare_res` останется равным 0.

Теперь предположим, что массивы различаются:

```c
const unsigned char arr1[] = {0x48, 0x65, 0x6C, 0x6C, 0x6F}; // "Hello"
const unsigned char arr2[] = {0x48, 0x65, 0x6C, 0x6C, 0x41}; // "Hella"
```

На последней итерации цикла:
- `ptr_byte1[4]` будет равно `0x6F` (символ 'o').
- `ptr_byte2[4]` будет равно `0x41` (символ 'A').
- Разность `0x6F - 0x41` даст положительное значение, указывая на то, что `arr1` больше `arr2`.

### Заключение

Использование `unsigned char` для побайтового сравнения данных обеспечивает точное и безопасное сравнение, избегая проблем с интерпретацией знаковых байтов и гарантируя, что каждое значение будет рассматриваться в диапазоне от 0 до 255.

*/




/*
0x48 - это шестнадцатеричное (или хексадецимальное) представление числа в программировании и компьютерных науках. Шестнадцатеричная система счисления используется для компактного представления байтов и часто применяется в программировании и отладке кода.

### Шестнадцатеричная система счисления

Шестнадцатеричная система счисления (или хексадецимальная) основана на числе 16. Она использует следующие символы для представления значений:

- 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 (десятичные значения 0-9)
- A, B, C, D, E, F (десятичные значения 10-15)

### Пример

0x48 - это шестнадцатеричное число, где:
- 4 - старший (более значимый) полубайт
- 8 - младший (менее значимый) полубайт

Чтобы преобразовать это число в десятичное, нужно использовать формулу:

\[ \text{значение} = 4 \times 16^1 + 8 \times 16^0 \]

Таким образом:
\[ \text{значение} = 4 \times 16 + 8 \times 1 = 64 + 8 = 72 \]

В десятичной системе счисления 0x48 равно 72.

### ASCII-код

Шестнадцатеричные числа часто используются для представления символов в кодировке ASCII (American Standard Code for Information Interchange). В ASCII код символа 'H' равен 72 в десятичной системе, что соответствует 0x48 в шестнадцатеричной системе.

### Пример использования в коде

Рассмотрим массив байтов, который представляет строку "Hello":

```c
const unsigned char arr[] = {0x48, 0x65, 0x6C, 0x6C, 0x6F}; // "Hello"
```

Здесь:
- 0x48 соответствует символу 'H'
- 0x65 соответствует символу 'e'
- 0x6C соответствует символу 'l'
- 0x6F соответствует символу 'o'

### Преимущества использования шестнадцатеричной системы

1. **Компактность**: Шестнадцатеричная система позволяет компактно записывать байты. Например, 0x48 вместо 72.
2. **Читабельность**: Программистам легче читать и понимать шестнадцатеричные числа при отладке, особенно когда речь идет о значениях байтов и машинном коде.
3. **Соответствие с машинным кодом**: В машинном коде и отладочных инструментах часто используются шестнадцатеричные числа, так как они напрямую соответствуют битовым значениям байтов.

### Заключение

Шестнадцатеричные числа, такие как 0x48, широко используются в программировании для представления значений байтов. Они компактны, удобны для чтения и соответствуют значениям, используемым в компьютерной архитектуре и отладке.

*/




/*

Понял, что ваше замечание о том, что условие `compare_res == 0` может быть неправильно понято. Давайте уточним.

### Условие `compare_res == 0`

Цикл должен продолжаться, пока `compare_res` остается равным нулю. Это условие означает, что цикл продолжается до тех пор, пока не будет найдено различие между байтами сравниваемых массивов. Вот как это работает:

1. **Инициализация**:
   - `compare_res` инициализируется значением 0.
   - Это означает, что в начале работы цикла предполагается, что массивы идентичны.

2. **Условие продолжения цикла**:
   - `i < n && compare_res == 0`
   - `i < n`: цикл продолжается, пока `i` меньше `n`, что гарантирует, что цикл выполнится не более чем `n` раз.
   - `compare_res == 0`: цикл продолжается, пока `compare_res` равно 0. Если `compare_res` становится ненулевым, это значит, что найдено различие, и цикл прекращается.

### Пример кода

Давайте рассмотрим тот же пример кода:

```c
#include "../s21_string.h"

int s21_memcmp(const void *mem1, const void *mem2, s21_size_t n) {
    int compare_res = 0; // Инициализация переменной результат сравнения

    const unsigned char *ptr_byte1 = (const unsigned char *)mem1;
    const unsigned char *ptr_byte2 = (const unsigned char *)mem2;

    for (s21_size_t i = 0; i < n && compare_res == 0; i++) {
        if (ptr_byte1[i] != ptr_byte2[i]) {
            compare_res = ptr_byte1[i] - ptr_byte2[i];
        }
    }

    return compare_res;
}
```

### Пошаговое объяснение

1. **Инициализация**:
   - `compare_res` инициализируется значением 0, что означает, что до начала цикла предполагается, что массивы идентичны.

2. **Начало цикла**:
   - `for (s21_size_t i = 0; i < n && compare_res == 0; i++) {`
   - Цикл продолжается до тех пор, пока `i` меньше `n` и `compare_res` равно 0.

3. **Сравнение байтов**:
   - Внутри цикла каждый байт `ptr_byte1[i]` сравнивается с соответствующим байтом `ptr_byte2[i]`.

4. **Обнаружение различия**:
   - Если найдено различие (`ptr_byte1[i] != ptr_byte2[i]`), переменная `compare_res` получает значение разности этих байтов (`ptr_byte1[i] - ptr_byte2[i]`).
   - Как только `compare_res` становится ненулевым, цикл прекращается, так как условие `compare_res == 0` больше не выполняется.

### Пример

Рассмотрим пример:

```c
const unsigned char arr1[] = {0x48, 0x65, 0x6C, 0x6C, 0x6F}; // "Hello"
const unsigned char arr2[] = {0x48, 0x65, 0x6C, 0x6C, 0x41}; // "Hella"
s21_size_t n = 5;
int compare_res = 0;

const unsigned char *ptr_byte1 = arr1;
const unsigned char *ptr_byte2 = arr2;

for (s21_size_t i = 0; i < n && compare_res == 0; i++) {
    if (ptr_byte1[i] != ptr_byte2[i]) {
        compare_res = ptr_byte1[i] - ptr_byte2[i];
    }
}
```

### Пошаговый анализ:

1. **Итерация 1**: `i = 0`
   - `ptr_byte1[0]` (0x48) == `ptr_byte2[0]` (0x48)
   - `compare_res` остается 0

2. **Итерация 2**: `i = 1`
   - `ptr_byte1[1]` (0x65) == `ptr_byte2[1]` (0x65)
   - `compare_res` остается 0

3. **Итерация 3**: `i = 2`
   - `ptr_byte1[2]` (0x6C) == `ptr_byte2[2]` (0x6C)
   - `compare_res` остается 0

4. **Итерация 4**: `i = 3`
   - `ptr_byte1[3]` (0x6C) == `ptr_byte2[3]` (0x6C)
   - `compare_res` остается 0

5. **Итерация 5**: `i = 4`
   - `ptr_byte1[4]` (0x6F) != `ptr_byte2[4]` (0x41)
   - `compare_res` = 0x6F - 0x41 = 0x2E (положительное значение)

Цикл завершится после пятой итерации, так как обнаружено различие и `compare_res` больше не равно 0.

Таким образом, условие `i < n && compare_res == 0` позволяет циклу эффективно и безопасно сравнивать два массива байт, прекращая выполнение сразу после нахождения первого различия или достижения заданного количества байтов.

*/
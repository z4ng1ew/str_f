#include "../s21_string.h"

char *s21_strncpy(char *dest, const char *src, s21_size_t n) {

  /*
   Функции `strncpy()` и `memcpy()` в языке C служат для копирования данных, но они имеют разные особенности и предназначены для разных типов данных. Вот основные различия между ними:

  ### `strncpy()`
`strncpy()` копирует заданное количество символов из одной строки в другую, при этом учитывает символ окончания строки `\0`.

  #### Прототип:
```c
char *strncpy(char *dest, const char *src, size_t n);
```

  #### Параметры:
- `dest`: указатель на массив назначения (куда копируются данные).
- `src`: указатель на исходную строку.
- `n`: максимальное количество символов для копирования.

  #### Особенности:
1. **Копирование строк**: предназначена для работы со строками.
2. **Символ окончания строки**: если длина `src` меньше `n`, то `dest` будет дополнен символами `\0` до `n`.
3. **Безопасность**: гарантирует, что `dest` будет корректно завершен символом `\0`, если `src` меньше `n`.

  #### Пример:
```c
char src[] = "hello";
char dest[10];
strncpy(dest, src, 10);
// dest будет содержать "hello\0\0\0\0\0"
```

  ### `memcpy()`
`memcpy()` копирует заданное количество байт из одной области памяти в другую, не учитывая содержимое данных.

#### Прототип:
```c
void *memcpy(void *dest, const void *src, size_t n);
```

  #### Параметры:
- `dest`: указатель на область памяти назначения.
- `src`: указатель на исходную область памяти.
- `n`: количество байт для копирования.

  #### Особенности:
1. **Копирование произвольных данных**: предназначена для копирования любых типов данных, не только строк.
2. **Скорость**: может быть более эффективной, так как не проверяет и не добавляет символы `\0`.
3. **Прямое копирование**: копирует точно `n` байт, не завершая данные никаким специальным символом.

  #### Пример:
```c
int src[] = {1, 2, 3, 4, 5};
int dest[5];
memcpy(dest, src, 5 * sizeof(int));
// dest будет содержать {1, 2, 3, 4, 5}
```

  ### Основные различия:

1. **Тип данных**:
   - `strncpy()` работает со строками и символами, учитывая символ `\0`.
   - `memcpy()` работает с произвольными блоками памяти, независимо от их содержимого.

2. **Символ окончания строки**:
   - `strncpy()` завершает строку символами `\0`, если длина исходной строки меньше `n`.
   - `memcpy()` не добавляет никаких символов, просто копирует байты.

3. **Использование**:
   - `strncpy()` используется для безопасного копирования строк.
   - `memcpy()` используется для копирования произвольных данных, например, массивов структур или двоичных данных.

  ### Примеры использования

  #### `strncpy()`
```c
#include <stdio.h>
#include <string.h>

int main() {
    char src[] = "hello";
    char dest[10];
    strncpy(dest, src, 10);

    printf("dest: %s\n", dest); // Output: "hello"
    return 0;
}
```

  #### `memcpy()`
```c
#include <stdio.h>
#include <string.h>

int main() {
    int src[] = {1, 2, 3, 4, 5};
    int dest[5];
    memcpy(dest, src, 5 * sizeof(int));

    for (int i = 0; i < 5; i++) {
        printf("dest[%d]: %d\n", i, dest[i]);
    }
    // Output: 1, 2, 3, 4, 5
    return 0;
}
```

  ### Итог

- `strncpy()` используется для копирования строк с учетом символа окончания строки.
- `memcpy()` используется для копирования произвольных блоков памяти, не зависящих от типа данных и их содержимого.

   */



/*
  Функция s21_strncpy принимает три параметра:

  char *dest: указатель на строку назначения, куда будут копироваться символы.
  const char *src: указатель на исходную строку, откуда будут копироваться символы.
  s21_size_t n: количество символов, которое нужно скопировать.

*/

  s21_size_t i; // если не объявить то появится предупреждение - ‘i’ undeclared (first use in this function)


  for (i = 0; i < n; i++) {


    if (src[i]) { //src[i] возвращает символ строки src на позиции i.В языке C любая ненулевая (не равная нулю) величина считается истинной (true), а нулевая величина — ложной (false).Если src[i] содержит ненулевой символ, условие if будет истинным.

      dest[i] = src[i]; //происходит присваивание значения текущего символа из строки src в соответствующую позицию строки dest. Давайте разберем этот процесс подробно.



    } else {

      dest[i] = '\0';   //Если текущий элемент src[i] является нулевым символом (конец строки), выполняется строка dest[i] = '\0';.
    }


  }

  return dest; //возвращает указатель dest, то есть адрес первого элемента массива dest. Проще говоря -  функция возвращает указатель на начало строки назначения.
}

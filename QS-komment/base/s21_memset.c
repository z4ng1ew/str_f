#include "../s21_string.h"

//Функция memset расшифровывается как "memory set", что можно перевести как "установка памяти". Название функции отражает её назначение: она устанавливает все байты в определенной области памяти на заданное значение.


void *s21_memset(void *str, int c, s21_size_t n) { 

  //void *str — указатель на область памяти, которую нужно заполнить.
  //int c — значение, которым будет заполняться память. Хотя это значение типа int, оно приводится к типу unsigned char при записи в память.
  //s21_size_t n — количество байт, которые нужно заполнить.


  unsigned char *byte_ptr = (unsigned char *)str; //unsigned char *p — объявляем указатель p на тип unsigned char.  //(unsigned char *)str — приводим указатель str к типу unsigned char *, чтобы работать с памятью побайтово.

  for (s21_size_t i = 0; i < n; i++) { //Цикл for выполняется n раз, где n — количество байт, которые нужно заполнить.
    *byte_ptr++ = c; //p++ перемещает указатель на второй третий четвёртый и т.д. байты массива.

    // параметр "c" представляет собой значение, которым мы будем заполнять указанную область памяти. Хотя c имеет тип int, он приводится к типу unsigned char перед записью в память. Это означает, что только младшие 8 бит значения c будут использоваться.
  }

  /*

  *p указывает на первый байт массива.
  *p = 65 устанавливает первый байт равным 65.
  p++ перемещает указатель на второй байт массива.
  i увеличивается до 1.
  */

  return str; // указатель на заполненную память, которая была передана в функцию.
}





/*
Конечно, давайте подробно разберем эту часть кода:

### Цикл `for` и его работа

```c
for (s21_size_t i = 0; i < n; i++) {
    *p++ = c;
}
```

Этот цикл отвечает за заполнение памяти значением `c` побайтово. Давайте рассмотрим его компоненты и работу пошагово:

1. **Инициализация цикла**:
   ```c
   s21_size_t i = 0;
   ```
   В начале цикла переменная `i` инициализируется значением `0`. `s21_size_t` - это, вероятно, определение типа для размера в байтах, аналогично `size_t`.

2. **Условие продолжения цикла**:
   ```c
   i < n;
   ```
   Цикл продолжается, пока `i` меньше `n`. `n` - это количество байт, которые нужно заполнить.

3. **Инкремент переменной**:
   ```c
   i++
   ```
   После каждой итерации цикла значение `i` увеличивается на `1`.

4. **Тело цикла**:
   ```c
   *p++ = c;
   ```
   Здесь происходит основное действие:
   - `*p` - это разыменование указателя `p`, то есть доступ к байту памяти, на который указывает `p`.
   - `*p = c` - установка текущего байта памяти значением `c`.
   - `p++` - инкремент указателя `p`, то есть после установки значения `c` в текущий байт, указатель `p` увеличивается и начинает указывать на следующий байт памяти.

### Пошаговый пример работы цикла

Предположим, что у нас есть массив из 5 байт, и мы хотим заполнить его значением `65` (символ 'A' в ASCII). 

1. **Инициализация**:
   - `p` указывает на начало массива.
   - `n` = 5.

2. **Первая итерация (i = 0)**:
   - `*p` указывает на первый байт массива.
   - `*p = 65` устанавливает первый байт равным 65.
   - `p++` перемещает указатель на второй байт массива.
   - `i` увеличивается до 1.

3. **Вторая итерация (i = 1)**:
   - `*p` указывает на второй байт массива.
   - `*p = 65` устанавливает второй байт равным 65.
   - `p++` перемещает указатель на третий байт массива.
   - `i` увеличивается до 2.

4. **Третья итерация (i = 2)**:
   - `*p` указывает на третий байт массива.
   - `*p = 65` устанавливает третий байт равным 65.
   - `p++` перемещает указатель на четвертый байт массива.
   - `i` увеличивается до 3.

5. **Четвертая итерация (i = 3)**:
   - `*p` указывает на четвертый байт массива.
   - `*p = 65` устанавливает четвертый байт равным 65.
   - `p++` перемещает указатель на пятый байт массива.
   - `i` увеличивается до 4.

6. **Пятая итерация (i = 4)**:
   - `*p` указывает на пятый байт массива.
   - `*p = 65` устанавливает пятый байт равным 65.
   - `p++` перемещает указатель на следующий байт (за пределы массива).
   - `i` увеличивается до 5.

7. **Завершение**:
   - Теперь `i` равно 5, что не удовлетворяет условию `i < n`, поэтому цикл завершается.

### Итоговое состояние памяти

После выполнения цикла память (массив) будет заполнена значениями `65`:

```
65 65 65 65 65
```

### Полный код функции с пояснениями

```c
#include "../s21_string.h"

void *s21_memset(void *str, int c, s21_size_t n) {
    unsigned char *p = (unsigned char *)str; // Приведение указателя str к типу unsigned char *, чтобы работать с памятью побайтово.

    for (s21_size_t i = 0; i < n; i++) { // Цикл выполняется n раз, где n — количество байт, которые нужно заполнить.
        *p++ = c; // Установка текущего байта значением c и переход к следующему байту.
    }

    return str; // Возвращаем исходный указатель.
}
```

Этот цикл заполняет область памяти значением `c` по байтам, начиная с адреса, на который указывает `str`.

*/







/*

void *s21_memset(void *str, int c, s21_size_t n) { 

(unsigned char *)str; 

  for (s21_size_t i = 0; i < n; i++) { 
    *str++ = c; 
  }

  return str; 
}



int main(){
    char arr[10];


    s21_memset(arr, 'd', sizeof(arr));

    arr[9] = '\0';

    printf("Result %s\n", arr);

    return 0;
}




Ошибка, с которой вы столкнулись, связана с тем, что вы пытаетесь разыменовать указатель типа `void *`, что недопустимо в C. Указатель типа `void *` не имеет информации о том, какого типа данные он указывает, поэтому его нужно привести к конкретному типу, чтобы разыменовать.

Для функции `s21_memset` логично привести указатель `str` к типу `unsigned char *`, так как `unsigned char` гарантированно имеет размер 1 байт и позволяет работать с памятью побайтово.

Вот исправленный код:

### Исправленный код функции `s21_memset`

```c
#include <stdio.h>

typedef unsigned long s21_size_t;

void *s21_memset(void *str, int c, s21_size_t n) {
    unsigned char *p = (unsigned char *)str; // Приведение указателя str к типу unsigned char *

    for (s21_size_t i = 0; i < n; i++) {
        *p++ = (unsigned char)c; // Присваиваем значение c, приведенное к unsigned char
    }

    return str;
}

int main() {
    char arr[10];

    s21_memset(arr, 'd', sizeof(arr));

    arr[9] = '\0';

    printf("Result: %s\n", arr);

    return 0;
}
```

### Объяснение

1. **Приведение указателя `str` к `unsigned char *`**:
   ```c
   unsigned char *p = (unsigned char *)str;
   ```
   Это позволяет работать с указателем как с указателем на байты.

2. **Цикл заполнения памяти**:
   ```c
   for (s21_size_t i = 0; i < n; i++) {
       *p++ = (unsigned char)c;
   }
   ```
   - `*p++ = (unsigned char)c` присваивает значение `c`, приведенное к `unsigned char`, текущему байту, на который указывает `p`.
   - Затем указатель `p` инкрементируется, чтобы указывать на следующий байт.

3. **Возврат исходного указателя `str`**:
   ```c
   return str;
   ```
   Возвращает указатель на начало области памяти, которую заполнили.

### Запуск программы

Когда вы скомпилируете и запустите исправленную программу, вы должны получить следующий результат:

```
Result: ddddddddd
```

Это означает, что массив `arr` был успешно заполнен символом `'d'`.

### Заключение

Исправление включает приведение указателя `str` к типу `unsigned char *` для корректного разыменования и записи значений. Это устраняет ошибки компиляции и предупреждения, с которыми вы столкнулись.

*/
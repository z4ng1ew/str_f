#include "../s21_string.h"

void *s21_memchr(const void *str, int c, s21_size_t n) {
  
  int found_ind = -1; //Переменная found_index инициализируется значением -1, что будет использоваться для индикации отсутствия искомого символа.

  for (s21_size_t cur_ind = 0; cur_ind < n &&  found_ind == -1; cur_ind++) {
  
    //Цикл for выполняет итерацию по каждому байту в первых n байтах блока памяти, начиная с str. Он проверяет каждый байт, чтобы определить, равен ли он искомому символу c. Если символ найден, цикл прекращается, и переменная  found_ind  получает значение индекса первого вхождения символа. Если символ не найден в первых n байтах, цикл завершается после проверки всех байтов, и переменная  found_ind  остается равной -1.

    // cur_ind < n  - Это условие гарантирует, что цикл будет выполняться только до тех пор, пока cur_ind (текущий индекс) меньше n (количество байтов для проверки). Таким образом, цикл проходит по каждому байту в блоке памяти от 0 до n-1.

    //0 до n-1 - Это означает, что если n равно 5, то цикл проверит байты с индексами от 0 до 4 включительно. Условие cur_ind < n гарантирует, что цикл не выйдет за пределы этого диапазона и завершится после проверки всех нужных байтов.


    //found_ind == -1 - это условие проверяет, что символ еще не был найден. Переменная found_ind инициализирована значением -1, что означает, что искомый символ не найден. Как только символ найден, found_ind устанавливается в текущий индекс (cur_ind), и это условие становится ложным, что прекращает выполнение цикла.


    //s21_size_t cur_ind = 0; - Соответствие типу параметра n: Параметр n имеет тип s21_size_t, который представляет количество байтов для проверки. Использование того же типа для переменной  found_ind  обеспечивает согласованность типов и предотвращает потенциальные ошибки, связанные с преобразованием типов.

    // До каких пор будет выполняться цикл?
    // Цикл будет выполняться до тех пор, пока оба условия истинны:
    // cur_ind меньше n, то есть пока не проверены все байты в первых n байтах блока памяти.
    // found_ind равно -1, то есть пока символ не найден.


    if (*((char *)str + cur_ind) == c){  //Значение байта сравнивается с искомым символом c. Обратите внимание, что c имеет тип int, поэтому фактически сравнивается байт с символом, представленным как значение char. 
    // str + cur_ind  -- str тоже нужно итерировать

    //ПО СУТИ МЫ ЗДЕСЬ СКЛАДЫВАЕМ УКАЗАТЕЛЬ НА char и  int !!!

    //!!! В языке C арифметика указателей позволяет выполнять операции сложения и вычитания указателей с целыми числами. Когда указатель прибавляется к целому числу, фактически происходит смещение указателя на указанное количество элементов типа, на который указывает указатель (что смещает указатель на cur_ind-ов байтов вперед). !!!!

    found_ind = cur_ind; //Если байт по адресу (char *)str + cur_ind равен искомому символу c, то переменной found_ind присваивается текущее значение индекса cur_ind
    }

    //== - является оператором сравнения. Он используется для проверки равенства двух значений.

    //Да, вы правильно понимаете: Преобразованный указатель str (теперь уже типа char *) используется для итерации по байтам в блоке памяти. Прибавление cur_ind к указателю смещает его на cur_ind байтов от начала блока памяти, на который указывает str.

    //Итерация по байтам: Это позволяет циклу for последовательно обрабатывать каждый байт в блоке памяти, начиная с первого байта (когда cur_ind равно 0) и до последнего (когда cur_ind достигает n-1).

    // Таким образом, прибавление cur_ind к указателю str перемещает обработку на следующий байт в блоке памяти, что и требуется для поиска символа в массиве байтов.

  } 

  if (found_ind == -1) {
    str = s21_NULL;
  }
  
  else {
    str = (char *)str +  found_ind; //В языке C указатели можно складывать с целыми числами, чтобы смещаться на определенное количество элементов типа, на который указывает указатель. Изначально str имеет тип const void *, который не позволяет делать арифметику указателей напрямую. Приведение str к типу char * позволяет выполнять арифметику указателей, так как char * указывает на байты, и прибавление целого числа к char * корректно смещает указатель на соответствующее количество байтов. //Прибавление found_ind к str смещает указатель str на found_ind байтов вперед от начала блока памяти.
  } //Почему это нужно? Смещение указателя: После того как символ найден, необходимо вернуть указатель на этот символ. 
  
    // !! Смещая исходный указатель str на found_ind байтов вперед, мы получаем указатель на первую позицию, где был найден символ c.  !!
  
    //Приведение типов: Приведение типов необходимо, чтобы можно было выполнять арифметику указателей на байты. В противном случае, компилятор не позволит складывать указатель типа void * с целым числом. Это позволяет функции вернуть указатель на этот символ, что соответствует ожидаемому поведению функции memchr.



  return (void *)((char *)str); //  Оператор return возвращает указатель, который сначала был преобразован к char *, а затем к void *. Функция s21_memchr предназначена для поиска первого вхождения символа в блоке памяти. Она возвращает указатель на найденный символ или NULL, если символ не найден. //
  
  // Преобразуем к void *, чтобы избавиться от предупреждения // если этого не сделать то появится ошибка  связаная с тем, что вы пытаетесь вернуть указатель типа const void * как void *. Это происходит потому, что исходный указатель str имеет квалификатор const, указывающий на неизменяемый блок памяти. Когда вы возвращаете его, компилятор предупреждает вас о том, что квалификатор const теряется.
}




/*

Давайте подробно разберем работу функции `s21_memchr` в контексте стандартной функции `memchr`, используя конкретный пример и аналогии.

### Общее описание функции `memchr`
Функция `memchr` ищет первое вхождение символа в блоке памяти. Она имеет следующий прототип:
```c
void *memchr(const void *str, int c, size_t n);
```
- `str`: указатель на блок памяти.
- `c`: искомый символ.
- `n`: количество байт для проверки.

Функция возвращает указатель на первое вхождение символа `c` или `NULL`, если символ не найден.

### Пример использования
Предположим, у нас есть массив байтов:
```c
unsigned char data[] = {10, 20, 30, 40, 50};
```
И мы хотим найти первое вхождение байта `30` в первых 5 байтах массива. Вызов функции будет выглядеть так:
```c
void *result = s21_memchr(data, 30, 5);
```

### Пошаговая логика функции `s21_memchr`
```c
void *s21_memchr(const void *str, int c, s21_size_t n) {
  int found_index = -1;
  for (s21_size_t i = 0; i < n && found_index == -1; i++) {
    if (*((char *)str + i) == c) found_index = i;
  }
  if (found_index == -1)
    str = s21_NULL;
  else
    str = (char *)str + found_index;
  return (void *)((char *)str);
}
```

1. **Инициализация переменной `found_index`:**
   ```c
   int found_index = -1;
   ```
   Переменная `found_index` инициализируется значением `-1`, что будет использоваться для индикации отсутствия искомого символа.

2. **Цикл поиска:**
   ```c
   for (s21_size_t i = 0; i < n && found_index == -1; i++) {
     if (*((char *)str + i) == c) found_index = i;
   }
   ```
   Этот цикл проходит через первые `n` байтов блока памяти:
   - На каждой итерации цикла `i` увеличивается от 0 до `n-1`.
   - `*((char *)str + i)` получает значение байта в позиции `i`.
   - Если этот байт равен `c`, `found_index` устанавливается в значение `i`, обозначая позицию первого вхождения символа.

   Для нашего примера:
   - На первой итерации: `i = 0`, значение `data[0]` (10) не равно 30.
   - На второй итерации: `i = 1`, значение `data[1]` (20) не равно 30.
   - На третьей итерации: `i = 2`, значение `data[2]` (30) равно 30. Переменная `found_index` устанавливается в `2`.

3. **Проверка результата поиска:**
   ```c
   if (found_index == -1)
     str = s21_NULL;
   else
     str = (char *)str + found_index;
   ```
   После цикла проверяется значение `found_index`:
   - Если `found_index` равно `-1`, символ не был найден, и `str` устанавливается в `s21_NULL`.
   - Если символ был найден (в нашем примере `found_index` равно 2), `str` устанавливается в указатель на первую позицию вхождения символа (`str + found_index`).

4. **Возвращение результата:**
   ```c
   return (void *)((char *)str);
   ```
   Возвращается указатель на найденный символ или `NULL`, если символ не был найден.

### Результат для нашего примера:
```c
unsigned char data[] = {10, 20, 30, 40, 50};
void *result = s21_memchr(data, 30, 5);
```
- Переменная `result` будет указывать на `&data[2]`, так как `30` находится на третьей позиции (индекс 2) массива.

### Аналогия
Представьте себе длинную ленту (массив) с цифрами (байтами). Функция `s21_memchr` — это человек, который проходит вдоль этой ленты и ищет первую встреченную цифру, которую вы ему сказали найти. Как только он находит нужную цифру, он запоминает это место и больше не продолжает искать. Если он нашел цифру, он возвращает вам указатель на это место на ленте. Если он прошел всю ленту и не нашел цифру, он говорит, что цифры нет (возвращает `NULL`).

*/





/*

Давайте подробно рассмотрим условие `cur_ind < n && found_ind == -1` и его значение в контексте вашего кода.

### Условие в контексте кода:

```c
void *s21_memchr(const void *str, int c, s21_size_t n) {
  
  int found_ind = -1; // Переменная found_ind инициализируется значением -1, что будет использоваться для индикации отсутствия искомого символа.

  for (s21_size_t cur_ind = 0; cur_ind < n && found_ind == -1; cur_ind++) {
    if (*((char *)str + cur_ind) == c)  found_ind = cur_ind;
  }

  if (found_ind == -1)
    str = s21_NULL;
  else
    str = (char *)str + found_ind;

  return (void *)((char *)str);
}
```

### Объяснение условия:

#### `cur_ind < n`
Это условие гарантирует, что цикл будет выполняться только до тех пор, пока `cur_ind` (текущий индекс) меньше `n` (количество байтов для проверки). Таким образом, цикл проходит по каждому байту в блоке памяти от `0` до `n-1`.

#### `found_ind == -1`
Это условие проверяет, что символ еще не был найден. Переменная `found_ind` инициализирована значением `-1`, что означает, что искомый символ не найден. Как только символ найден, `found_ind` устанавливается в текущий индекс (`cur_ind`), и это условие становится ложным, что прекращает выполнение цикла.

### В КОНТЕКСТЕ КОДА:
- **До каких пор будет выполняться цикл?**
  Цикл будет выполняться до тех пор, пока оба условия истинны:
  - `cur_ind` меньше `n`, то есть пока не проверены все байты в первых `n` байтах блока памяти.
  - `found_ind` равно `-1`, то есть пока символ не найден.

### Пример выполнения цикла:

Рассмотрим пример с массивом:
```c
unsigned char data[] = {10, 20, 30, 40, 50};
void *result = s21_memchr(data, 30, 5);
```

#### Итерации цикла:

1. **Инициализация:**
   - `cur_ind = 0`
   - `found_ind = -1`

2. **Первая итерация:**
   - `cur_ind = 0`
   - Проверяется `data[0]`, значение `10`
   - `10 != 30`, `found_ind` остается `-1`
   - `cur_ind` увеличивается на 1 (`cur_ind = 1`)

3. **Вторая итерация:**
   - `cur_ind = 1`
   - Проверяется `data[1]`, значение `20`
   - `20 != 30`, `found_ind` остается `-1`
   - `cur_ind` увеличивается на 1 (`cur_ind = 2`)

4. **Третья итерация:**
   - `cur_ind = 2`
   - Проверяется `data[2]`, значение `30`
   - `30 == 30`, `found_ind` устанавливается в `2`
   - Условие `found_ind == -1` становится ложным, цикл завершается

### Итог:

- Цикл будет выполняться до тех пор, пока не будут проверены все `n` байтов или пока не будет найден искомый символ `c`.
- Когда один из этих условий становится ложным (либо все байты проверены, либо символ найден), цикл завершает выполнение.


*/